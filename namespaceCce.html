<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.13"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Cce Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="popper.min.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v0.0.0</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="code_of_conduct.html">
              <i class="octicon octicon-comment-discussion"></i><span>Code of Conduct</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="contributing_to_spectre.html">
              <i class="octicon octicon-git-pull-request"></i><span>Contributing Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Code Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="citelist.html">
          <i class="octicon octicon-file-text"></i><span>Bibliography</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Cce Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains functionality for Cauchy Characteristic Extraction.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceCce_1_1Actions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce_1_1Actions.html">Actions</a></td></tr>
<tr class="memdesc:namespaceCce_1_1Actions"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of actions for use in the CCE evolution system. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceCce_1_1Tags"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce_1_1Tags.html">Tags</a></td></tr>
<tr class="memdesc:namespaceCce_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceCce_1_1Tags.html" title="Tags for Cauchy Characteristic Extraction routines. ">Tags</a> for Cauchy Characteristic Extraction routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace.html">ApplySwshJacobianInplace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a mutation to a spin-weighted spherical harmonic derivative value from the numerical coordinate (the spin-weighted derivative at fixed \(y\)) to the Bondi coordinates (the spin-weighted derivative at fixed \(r\)), inplace to the requested tag.  <a href="structCce_1_1ApplySwshJacobianInplace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTage51d3e9b700228a20725d336c7cc944d.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::Eth &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\eth\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTage51d3e9b700228a20725d336c7cc944d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag902c2fcc05e24b3dacb792bbd112b8d3.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::Ethbar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\bar{\eth}\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag902c2fcc05e24b3dacb792bbd112b8d3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag26ff3056ab474656d9f964b3753ed316.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::EthbarEth &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\bar{\eth} \eth\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag26ff3056ab474656d9f964b3753ed316.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag859aa457f41c680db2a89b63b27b73c4.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::EthbarEthbar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\bar{\eth} \bar{\eth}\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag859aa457f41c680db2a89b63b27b73c4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag984be51c54c04d4877afc39da0746165.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::EthEth &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\eth \eth\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag984be51c54c04d4877afc39da0746165.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTagde52d8f01d670e4258ec54c545dae50a.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::EthEthbar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\eth \bar{\eth}\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTagde52d8f01d670e4258ec54c545dae50a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue.html">CalculateScriPlusValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1News_01_4.html">CalculateScriPlusValue&lt; Tags::News &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Bondi news from the evolution quantities.  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1News_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi0_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::ScriPlus&lt; Tags::Psi0 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the leading part of \(\Psi_0\) near \(\mathcal I^+\).  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi0_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi1_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::ScriPlus&lt; Tags::Psi1 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the leading part of \(\Psi_1\) near \(\mathcal I^+\).  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi1_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi2_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::ScriPlus&lt; Tags::Psi2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the leading part of \(\Psi_2\) near \(\mathcal I^+\).  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi3_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::ScriPlus&lt; Tags::Psi3 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the leading part of \(\Psi_3\) near \(\mathcal I^+\).  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi3_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Strain_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::ScriPlus&lt; Tags::Strain &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the leading part of the strain \(h\) near \(\mathcal I^+\).  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Strain_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlusFactor_3_01Tags_1_1Psi4_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::ScriPlusFactor&lt; Tags::Psi4 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the contribution to the leading \(\Psi_4\) that multiplies the total time derivative.  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlusFactor_3_01Tags_1_1Psi4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1TimeIntegral_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi4_01_4_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::TimeIntegral&lt; Tags::ScriPlus&lt; Tags::Psi4 &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the contribution to the leading \(\Psi_4\) that corresponds to a total time derivative.  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1TimeIntegral_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi4_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_1_1Tags_1_1dt_3_01Tags_1_1InertialRetardedTime_01_4_01_4.html">CalculateScriPlusValue&lt;::Tags::dt&lt; Tags::InertialRetardedTime &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the time derivative of the asymptotically inertial time coordinate.  <a href="structCce_1_1CalculateScriPlusValue_3_1_1Tags_1_1dt_3_01Tags_1_1InertialRetardedTime_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CharacteristicEvolution.html">CharacteristicEvolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The component for handling the CCE evolution and waveform output.  <a href="structCce_1_1CharacteristicEvolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand.html">ComputeBondiIntegrand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes one of the inputs for the integration of one of the Characteristic hypersurface equations.  <a href="structCce_1_1ComputeBondiIntegrand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1Integrand_3_01Tags_1_1BondiBeta_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::Integrand&lt; Tags::BondiBeta &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(\beta\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1Integrand_3_01Tags_1_1BondiBeta_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1Integrand_3_01Tags_1_1BondiU_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::Integrand&lt; Tags::BondiU &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(U\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1Integrand_3_01Tags_1_1BondiU_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1LinearFactor_3_01Tags_1_1BondiH_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::LinearFactor&lt; Tags::BondiH &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the linear factor which multiplies \(H\) in the equation which determines the radial (y) dependence of the Bondi quantity \(H\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1LinearFactor_3_01Tags_1_1BondiH_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1LinearFactorForConjugate_3_01Tags_1_1BondiH_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::LinearFactorForConjugate&lt; Tags::BondiH &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the linear factor which multiplies \(\bar{H}\) in the equation which determines the radial (y) dependence of the Bondi quantity \(H\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1LinearFactorForConjugate_3_01Tags_1_1BondiH_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiH_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::PoleOfIntegrand&lt; Tags::BondiH &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pole part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(H\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiH_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiQ_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::PoleOfIntegrand&lt; Tags::BondiQ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pole part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(Q\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiQ_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiW_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::PoleOfIntegrand&lt; Tags::BondiW &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pole part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(W\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiW_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiH_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::RegularIntegrand&lt; Tags::BondiH &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pole part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(H\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiH_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiQ_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::RegularIntegrand&lt; Tags::BondiQ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the regular part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(Q\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiQ_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiW_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::RegularIntegrand&lt; Tags::BondiW &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the regular part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(W\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiW_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue.html">GaugeAdjustedBoundaryValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiBeta_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiBeta &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\hat \beta\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiBeta_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiH_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiH &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\hat H\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiH_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiJ_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiJ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\hat J\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiJ_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiQ_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiQ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\hat Q\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiQ_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiR_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge Bondi \(\hat R\) on the worldtube from Cauchy gauge quantities.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiU_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiU &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\mathcal U\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiU_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiW_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiW &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\hat W\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiW_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1Dr_3_01Tags_1_1BondiJ_01_4_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::Dr&lt; Tags::BondiJ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\partial_{\hat r} \hat J\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1Dr_3_01Tags_1_1BondiJ_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1DuRDividedByR_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::DuRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge \(\partial_{\hat u} \hat R / \hat R\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1DuRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeUpdateAngularFromCartesian.html">GaugeUpdateAngularFromCartesian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the angular coordinates stored in <code>AngularTag</code> via trigonometric operations applied to the Cartesian coordinates stored in <code>CartesianTag</code>.  <a href="structCce_1_1GaugeUpdateAngularFromCartesian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeUpdateInterpolator.html">GaugeUpdateInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the interpolator stored in <code><a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshInterpolator.html" title="Tag for a SwshInterpolator associated with a particular set of angular coordinates. ">Spectral::Swsh::Tags::SwshInterpolator</a>&lt;AngularCoordinates&gt;</code>.  <a href="structCce_1_1GaugeUpdateInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeUpdateJacobianFromCoordinates.html">GaugeUpdateJacobianFromCoordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">From the angular coordinates <code>AngularCoordinateTag</code> and the Cartesian coordinates <code>CartesianCoordinateTag</code>, determine the spin-weighted Jacobian factors <code>GaugeFactorSpin2</code> and <code>GaugeFactorSpin0</code>.  <a href="structCce_1_1GaugeUpdateJacobianFromCoordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeUpdateOmega.html">GaugeUpdateOmega</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the quantity \(\hat \omega\) and \(\hat \eth \hat \omega\) for updated spin-weighted Jacobian quantities \(\hat c\) and \(\hat d\).  <a href="structCce_1_1GaugeUpdateOmega.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeUpdateTimeDerivatives.html">GaugeUpdateTimeDerivatives</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the Cauchy gauge cartesian coordinate derivative \(\partial_u x(\hat x)\), as well as remaining gauge quantities \(\mathcal U^{(0)}\), \(\hat U \equiv \mathcal U - \mathcal U^{(0)}\), and \(\partial_{\hat u} \hat \omega\) to maintain asymptotically inertial angular coordinates.  <a href="structCce_1_1GaugeUpdateTimeDerivatives.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1H5WorldtubeBoundary.html">H5WorldtubeBoundary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component that supplies CCE worldtube boundary data.  <a href="structCce_1_1H5WorldtubeBoundary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1InitializeGauge.html">InitializeGauge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize to default values (identity transform) all of the angular gauge quantities for the boundary gauge transforms.  <a href="structCce_1_1InitializeGauge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1InitializeH5WorldtubeBoundary.html">InitializeH5WorldtubeBoundary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <a class="el" href="structCce_1_1H5WorldtubeBoundary.html" title="Component that supplies CCE worldtube boundary data. ">H5WorldtubeBoundary</a>.  <a href="structCce_1_1InitializeH5WorldtubeBoundary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1InitializeJ.html">InitializeJ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize \(J\) on the first hypersurface from provided boundary values of \(J\), \(R\), and \(\partial_r J\).  <a href="structCce_1_1InitializeJ.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1InitializeScriPlusValue_3_01Tags_1_1InertialRetardedTime_01_4.html">InitializeScriPlusValue&lt; Tags::InertialRetardedTime &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the inertial retarded time to the value provided in the mutator arguments.  <a href="structCce_1_1InitializeScriPlusValue_3_01Tags_1_1InertialRetardedTime_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html">pre_swsh_derivative_tags_to_compute_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by the set of template specializations of <code>ComputePreSwshDerivatives</code>.  <a href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies.html">PrecomputeCceDependencies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of procedures for computing the set of inputs to the CCE integrand computations that can be computed before any of the intermediate integrands are evaluated.  <a href="structCce_1_1PrecomputeCceDependencies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1BondiK_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::BondiK &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(K = \sqrt{1 + J \bar{J}}\).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1BondiK_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1BondiR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::BondiR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a volume version of Bondi radius of the worldtube \(R\) from its boundary value (by repeating it over the radial dimension)  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1BondiR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1DuRDividedByR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::DuRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(\partial_u R / R\) from its boundary value (by repeating it over the radial dimension).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1DuRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthEthbarRDividedByR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::EthEthbarRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(\eth \bar{\eth} R / R\) by differentiating and repeating the boundary value of \(R\).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthEthbarRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthEthRDividedByR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::EthEthRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(\eth \eth R / R\) by differentiating and repeating the boundary value of \(R\).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthEthRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthRDividedByR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::EthRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(\eth R / R\) by differentiating and repeating the boundary value of \(R\).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1OneMinusY_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::OneMinusY &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(1 - y\) for the CCE system.  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1OneMinusY_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives.html">PreSwshDerivatives</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of procedures for computing the set of inputs to the CCE integrand computations that are to be performed prior to the spin-weighted spherical harmonic differentiation (and for the first step in the series of integrations, after the <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">PrecomputeCceDependencies</a></code>)  <a href="structCce_1_1PreSwshDerivatives.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiJbar_01_4.html">PreSwshDerivatives&lt; Tags::BondiJbar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\bar{J}\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiJbar_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiQbar_01_4.html">PreSwshDerivatives&lt; Tags::BondiQbar &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiUbar_01_4.html">PreSwshDerivatives&lt; Tags::BondiUbar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\bar{U}\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiUbar_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1ComplexInertialRetardedTime_01_4.html">PreSwshDerivatives&lt; Tags::ComplexInertialRetardedTime &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the values of the inertial retarded time into a spin-weighted container so that spin-weighted derivatives can be taken.  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1ComplexInertialRetardedTime_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01Tag_00_01DerivKind_01_4_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Dy&lt; Spectral::Swsh::Tags::Derivative&lt; Tag, DerivKind &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the derivative with respect to the numerical radial coordinate \(y\) of a quantity which is a spin-weighted spherical harmonic derivative.  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01Tag_00_01DerivKind_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tag_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Dy&lt; Tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the derivative of the quantity represented by <code>Tag</code> with respect to the numerical radial coordinate \(y\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tags_1_1BondiBeta_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Dy&lt; Tags::BondiBeta &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the first derivative with respect to \(y\) of <code><a class="el" href="structCce_1_1Tags_1_1BondiBeta.html" title="Bondi parameter . ">Tags::BondiBeta</a></code>.  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tags_1_1BondiBeta_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tags_1_1BondiU_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Dy&lt; Tags::BondiU &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the first derivative with respect to \(y\) of <code><a class="el" href="structCce_1_1Tags_1_1BondiU.html" title="Bondi parameter . ">Tags::BondiU</a></code>.  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tags_1_1BondiU_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Exp2Beta_01_4.html">PreSwshDerivatives&lt; Tags::Exp2Beta &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\exp(2 \beta)\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Exp2Beta_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1JbarQMinus2EthBeta_01_4.html">PreSwshDerivatives&lt; Tags::JbarQMinus2EthBeta &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\bar{J} * (Q - 2 \eth \beta)\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1JbarQMinus2EthBeta_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Lhs_00_01Rhs_01_4_01_4.html">PreSwshDerivatives&lt;::Tags::Multiplies&lt; Lhs, Rhs &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of <code>Lhs</code> and <code>Rhs</code>.  <a href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Lhs_00_01Rhs_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Lhs_00_01Tags_1_1BondiJbar_01_4_01_4.html">PreSwshDerivatives&lt;::Tags::Multiplies&lt; Lhs, Tags::BondiJbar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of \(\bar{J}\) and the quantity represented by <code>Rhs</code>.  <a href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Lhs_00_01Tags_1_1BondiJbar_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Tags_1_1BondiJbar_00_01Rhs_01_4_01_4.html">PreSwshDerivatives&lt;::Tags::Multiplies&lt; Tags::BondiJbar, Rhs &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of \(\bar{J}\) and the quantity represented by <code>Rhs</code>.  <a href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Tags_1_1BondiJbar_00_01Rhs_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Tags_1_1BondiUbar_00_01Rhs_01_4_01_4.html">PreSwshDerivatives&lt;::Tags::Multiplies&lt; Tags::BondiUbar, Rhs &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of \(\bar{U}\) and the quantity represented by <code>Rhs</code>.  <a href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Tags_1_1BondiUbar_00_01Rhs_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1RadialIntegrateBondi.html">RadialIntegrateBondi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computational structs for evaluating the hypersurface integrals during CCE evolution. These are compatible with use in <code><a class="el" href="group__DataBoxGroup.html#gac9900e6610ba0bce5834e8cb035d834d" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code>.  <a href="structCce_1_1RadialIntegrateBondi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1RadialIntegrateBondi_3_01Tags_1_1BondiH_01_4.html">RadialIntegrateBondi&lt; Tags::BondiH &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1RadialIntegrateBondi_3_01Tags_1_1BondiQ_01_4.html">RadialIntegrateBondi&lt; Tags::BondiQ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1RadialIntegrateBondi_3_01Tags_1_1BondiW_01_4.html">RadialIntegrateBondi&lt; Tags::BondiW &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1ReducedSpecWorldtubeH5BufferUpdater.html">ReducedSpecWorldtubeH5BufferUpdater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classCce_1_1WorldtubeBufferUpdater.html" title="Abstract base class for utilities that are able to perform the buffer updating procedure needed by th...">WorldtubeBufferUpdater</a></code> specialized to the CCE input worldtube H5 file produced by the reduced SpEC format.  <a href="classCce_1_1ReducedSpecWorldtubeH5BufferUpdater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1ReducedWorldtubeBufferUpdater.html">ReducedWorldtubeBufferUpdater</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1ReducedWorldtubeDataManager.html">ReducedWorldtubeDataManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages the 'reduced' cached buffer dataset associated with a CCE worldtube and interpolates to requested time points to provide worldtube boundary data to the main evolution routines.  <a href="classCce_1_1ReducedWorldtubeDataManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ReducedWorldtubeModeRecorder.html">ReducedWorldtubeModeRecorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a compressed representation of SpEC-like worldtube data associated with just the spin-weighted scalars required to perform the CCE algorithm.  <a href="structCce_1_1ReducedWorldtubeModeRecorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ScriPlusInterpolationManager.html">ScriPlusInterpolationManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores necessary data and interpolates on to new time points at scri+.  <a href="structCce_1_1ScriPlusInterpolationManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html">ScriPlusInterpolationManager&lt; VectorTypeToInterpolate, ::Tags::Multiplies&lt; MultipliesLhs, MultipliesRhs &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores necessary data and interpolates on to new time points at scri+, multiplying two results together before supplying the result.  <a href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01Tags_1_1Du_3_01Tag_01_4_01_4.html">ScriPlusInterpolationManager&lt; VectorTypeToInterpolate, Tags::Du&lt; Tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores necessary data and interpolates on to new time points at scri+, differentiating before supplying the result.  <a href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01Tags_1_1Du_3_01Tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html">second_swsh_derivative_tags_to_compute_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by multiple spin-weighted differentiation using utilities from the <code>Swsh</code> namespace.  <a href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by single spin-weighted differentiation using utilities from the <code>Swsh</code> namespace.  <a href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1SpecWorldtubeH5BufferUpdater.html">SpecWorldtubeH5BufferUpdater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classCce_1_1WorldtubeBufferUpdater.html" title="Abstract base class for utilities that are able to perform the buffer updating procedure needed by th...">WorldtubeBufferUpdater</a></code> specialized to the CCE input worldtube H5 file produced by SpEC.  <a href="classCce_1_1SpecWorldtubeH5BufferUpdater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1WorldtubeBufferUpdater.html">WorldtubeBufferUpdater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for utilities that are able to perform the buffer updating procedure needed by the <code><a class="el" href="classCce_1_1WorldtubeDataManager.html" title="Manages the cached buffer data associated with a CCE worldtube and interpolates to requested time poi...">WorldtubeDataManager</a></code>.  <a href="classCce_1_1WorldtubeBufferUpdater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1WorldtubeDataManager.html">WorldtubeDataManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages the cached buffer data associated with a CCE worldtube and interpolates to requested time points to provide worldtube boundary data to the main evolution routines.  <a href="classCce_1_1WorldtubeDataManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab0dea207566763a18d7d2f6532bd5dfd"><td class="memItemLeft" align="right" valign="top"><a id="ab0dea207566763a18d7d2f6532bd5dfd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SphericaliCartesianJ</b> = Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt;::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:ab0dea207566763a18d7d2f6532bd5dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2357637bb167d0426e1a45672def65"><td class="memItemLeft" align="right" valign="top"><a id="abe2357637bb167d0426e1a45672def65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CartesianiSphericalJ</b> = Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a>, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt;::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;&gt; &gt;</td></tr>
<tr class="separator:abe2357637bb167d0426e1a45672def65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa681669edbebc79cba9ee0b268db7230"><td class="memItemLeft" align="right" valign="top"><a id="aa681669edbebc79cba9ee0b268db7230"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AngulariCartesianA</b> = Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 2, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt;::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;, <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">SpacetimeIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:aa681669edbebc79cba9ee0b268db7230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f2be398a836fdcf44ea1d29c080b6f"><td class="memItemLeft" align="right" valign="top"><a id="a73f2be398a836fdcf44ea1d29c080b6f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SphericaliCartesianjj</b> = Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt;::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:a73f2be398a836fdcf44ea1d29c080b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613ab75a0e0153ef33518a6b3f358457"><td class="memTemplParams" colspan="2"><a id="a613ab75a0e0153ef33518a6b3f358457"></a>
template&lt;typename BondiVariable &gt; </td></tr>
<tr class="memitem:a613ab75a0e0153ef33518a6b3f358457"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a613ab75a0e0153ef33518a6b3f358457">integrand_terms_to_compute_for_bondi_variable</a> = typename detail::integrand_terms_to_compute_for_bondi_variable_impl&lt; BondiVariable &gt;::type</td></tr>
<tr class="memdesc:a613ab75a0e0153ef33518a6b3f358457"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct for providing a <code>tmpl::list</code> of integrand tags that need to be computed before integration can proceed for a given Bondi variable tag. <br /></td></tr>
<tr class="separator:a613ab75a0e0153ef33518a6b3f358457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b589ed5dc0a4995bee4ef742972e7a0"><td class="memItemLeft" align="right" valign="top"><a id="a8b589ed5dc0a4995bee4ef742972e7a0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a8b589ed5dc0a4995bee4ef742972e7a0">gauge_adjustments_setup_tags</a> = tmpl::list&lt; <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a>, <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a>, <a class="el" href="structCce_1_1Tags_1_1Dr.html">Tags::Dr</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt; &gt;</td></tr>
<tr class="memdesc:a8b589ed5dc0a4995bee4ef742972e7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of tags that should be calculated before the initial data is computed on the first hypersurface. <br /></td></tr>
<tr class="separator:a8b589ed5dc0a4995bee4ef742972e7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa380f6f1dc1109be44f9ddbac98652"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a> = tmpl::list&lt; <a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a>, <a class="el" href="structCce_1_1Tags_1_1BondiQ.html">Tags::BondiQ</a>, <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a>, <a class="el" href="structCce_1_1Tags_1_1BondiW.html">Tags::BondiW</a>, <a class="el" href="structCce_1_1Tags_1_1BondiH.html">Tags::BondiH</a> &gt;</td></tr>
<tr class="separator:a6aa380f6f1dc1109be44f9ddbac98652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393d5c196acb92779ba89acbc1fa686e"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a393d5c196acb92779ba89acbc1fa686e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a393d5c196acb92779ba89acbc1fa686e">integrand_temporary_tags</a> = typename <a class="el" href="structCce_1_1ComputeBondiIntegrand.html">ComputeBondiIntegrand</a>&lt; Tag &gt;::temporary_tags</td></tr>
<tr class="separator:a393d5c196acb92779ba89acbc1fa686e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00307a414eb1f569706cb7d7449fa4d"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class BoundaryPrefix&gt; </td></tr>
<tr class="memitem:aa00307a414eb1f569706cb7d7449fa4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aa00307a414eb1f569706cb7d7449fa4d">pre_computation_boundary_tags</a> = tmpl::list&lt; BoundaryPrefix&lt; <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a> &gt;, BoundaryPrefix&lt; <a class="el" href="structCce_1_1Tags_1_1DuRDividedByR.html">Tags::DuRDividedByR</a> &gt; &gt;</td></tr>
<tr class="memdesc:aa00307a414eb1f569706cb7d7449fa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of <code>BoundaryValue</code> tags needed as an input to any of the template specializations of <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">PrecomputeCceDependencies</a></code>.  <a href="#aa00307a414eb1f569706cb7d7449fa4d">More...</a><br /></td></tr>
<tr class="separator:aa00307a414eb1f569706cb7d7449fa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4a1a7fe54a9f77fbf034fb95f46474"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a7a4a1a7fe54a9f77fbf034fb95f46474">pre_computation_tags</a> = tmpl::list&lt; <a class="el" href="structCce_1_1Tags_1_1EthRDividedByR.html">Tags::EthRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthEthRDividedByR.html">Tags::EthEthRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthEthbarRDividedByR.html">Tags::EthEthbarRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1BondiK.html">Tags::BondiK</a>, <a class="el" href="structCce_1_1Tags_1_1OneMinusY.html">Tags::OneMinusY</a>, <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a> &gt;</td></tr>
<tr class="memdesc:a7a4a1a7fe54a9f77fbf034fb95f46474"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by the set of template specializations of <code>PrecomputeCceDepedencies</code>.  <a href="#a7a4a1a7fe54a9f77fbf034fb95f46474">More...</a><br /></td></tr>
<tr class="separator:a7a4a1a7fe54a9f77fbf034fb95f46474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f639bb3b07cc123bdf53c26dbf0fff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ad3f639bb3b07cc123bdf53c26dbf0fff">all_swsh_derivative_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a>, tmpl::bind&lt; tmpl::list, <a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a>&lt; tmpl::_1 &gt;, <a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html">second_swsh_derivative_tags_to_compute_for</a>&lt; tmpl::_1 &gt; &gt;&gt; &gt;&gt;</td></tr>
<tr class="memdesc:ad3f639bb3b07cc123bdf53c26dbf0fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by spin-weighted differentiation using utilities from the <code>Swsh</code> namespace.  <a href="#ad3f639bb3b07cc123bdf53c26dbf0fff">More...</a><br /></td></tr>
<tr class="separator:ad3f639bb3b07cc123bdf53c26dbf0fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbd52ad55ee87beb6abf5857c2db60a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9cbd52ad55ee87beb6abf5857c2db60a">all_transform_buffer_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; <a class="el" href="namespaceCce.html#ad3f639bb3b07cc123bdf53c26dbf0fff">all_swsh_derivative_tags</a>, tmpl::bind&lt; <a class="el" href="group__SwshGroup.html#ga3a19e1d6fbdabe80a1252971f6594cfb">Spectral::Swsh::coefficient_buffer_tags_for_derivative_tag</a>, tmpl::_1 &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:a9cbd52ad55ee87beb6abf5857c2db60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the full set of coefficient buffers needed to process all of the tags in <code>all_swsh_derivative_tags</code> using batch processing provided in <code>mutate_all_swsh_derivatives_for_tag</code>.  <a href="#a9cbd52ad55ee87beb6abf5857c2db60a">More...</a><br /></td></tr>
<tr class="separator:a9cbd52ad55ee87beb6abf5857c2db60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0c1285825dea59ca2860b31e2c0672"><td class="memItemLeft" align="right" valign="top"><a id="a9a0c1285825dea59ca2860b31e2c0672"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9a0c1285825dea59ca2860b31e2c0672">all_pre_swsh_derivative_tags_for_scri</a> = tmpl::list&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Du.html">Tags::Du</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt; &gt;, <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiW.html">Tags::BondiW</a> &gt; &gt;, <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt; &gt;&gt;, <a class="el" href="structCce_1_1Tags_1_1ComplexInertialRetardedTime.html">Tags::ComplexInertialRetardedTime</a> &gt;</td></tr>
<tr class="memdesc:a9a0c1285825dea59ca2860b31e2c0672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typelist of steps for <code><a class="el" href="structCce_1_1PreSwshDerivatives.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that are to be ...">PreSwshDerivatives</a></code> mutations needed for scri+ computations. <br /></td></tr>
<tr class="separator:a9a0c1285825dea59ca2860b31e2c0672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd34947472e61d70007727517310500"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a7dd34947472e61d70007727517310500">all_pre_swsh_derivative_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; tmpl::transform&lt; <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a>, tmpl::bind&lt; tmpl::list, <a class="el" href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html">pre_swsh_derivative_tags_to_compute_for</a>&lt; tmpl::_1 &gt;, detail::additional_pre_swsh_derivative_tags_for&lt; tmpl::_1 &gt; &gt;&gt;, <a class="el" href="namespaceCce.html#a9a0c1285825dea59ca2860b31e2c0672">all_pre_swsh_derivative_tags_for_scri</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a7dd34947472e61d70007727517310500"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the full set of tags needed as direct or indirect input to any <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations...">ComputeBondiIntegrand</a></code> that are computed any specialization of <code>ComputePreSwshDerivatives</code>.  <a href="#a7dd34947472e61d70007727517310500">More...</a><br /></td></tr>
<tr class="separator:a7dd34947472e61d70007727517310500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f9e086aabaeec7a2aedb1bb40605cb"><td class="memItemLeft" align="right" valign="top"><a id="ad4f9e086aabaeec7a2aedb1bb40605cb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ad4f9e086aabaeec7a2aedb1bb40605cb">all_swsh_derivative_tags_for_scri</a> = tmpl::list&lt; <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Eth.html">Spectral::Swsh::Tags::Eth</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a>, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1EthEthbar.html">Spectral::Swsh::Tags::EthEthbar</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Ethbar.html">Spectral::Swsh::Tags::Ethbar</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Du.html">Tags::Du</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt; &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Ethbar.html">Spectral::Swsh::Tags::Ethbar</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a> &gt; &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Ethbar.html">Spectral::Swsh::Tags::Ethbar</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiQ.html">Tags::BondiQ</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Ethbar.html">Spectral::Swsh::Tags::Ethbar</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Eth.html">Spectral::Swsh::Tags::Eth</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a> &gt; &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Eth.html">Spectral::Swsh::Tags::Eth</a> &gt; &gt;</td></tr>
<tr class="memdesc:ad4f9e086aabaeec7a2aedb1bb40605cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typelist of steps for <code>SwshDerivatives</code> mutations called on volume quantities needed for scri+ computations. <br /></td></tr>
<tr class="separator:ad4f9e086aabaeec7a2aedb1bb40605cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7f7d9ff20deabef15333769ea919c2"><td class="memItemLeft" align="right" valign="top"><a id="a2f7f7d9ff20deabef15333769ea919c2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a2f7f7d9ff20deabef15333769ea919c2">all_boundary_swsh_derivative_tags_for_scri</a> = tmpl::list&lt; <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1ComplexInertialRetardedTime.html">Tags::ComplexInertialRetardedTime</a>, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1EthEth.html">Spectral::Swsh::Tags::EthEth</a> &gt; &gt;</td></tr>
<tr class="memdesc:a2f7f7d9ff20deabef15333769ea919c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typelist of steps for <code>SwshDerivatives</code> mutations called on boundary (angular grid only) quantities needed for scri+ computations. <br /></td></tr>
<tr class="separator:a2f7f7d9ff20deabef15333769ea919c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3fb4002f488cbb49de99c785b1c1b5"><td class="memTemplParams" colspan="2"><a id="aad3fb4002f488cbb49de99c785b1c1b5"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:aad3fb4002f488cbb49de99c785b1c1b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aad3fb4002f488cbb49de99c785b1c1b5">OnDemandInputsForSwshJacobian</a> = detail::OnDemandInputsForSwshJacobianImpl&lt; Tag, <a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; int, Tag::type::type::spin &gt;, <a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a> &gt;</td></tr>
<tr class="memdesc:aad3fb4002f488cbb49de99c785b1c1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an expression template or reference to <code>Tag</code>, intended for situations for which a repeated computation is more desirable than storing a value in the <a class="el" href="group__DataBoxGroup.html">DataBox</a> (e.g. for conjugation and simple product rule expansion). <br /></td></tr>
<tr class="separator:aad3fb4002f488cbb49de99c785b1c1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae3c2adc1f0d1a2b33905452c9b9a645b"><td class="memTemplParams" colspan="2"><a id="ae3c2adc1f0d1a2b33905452c9b9a645b"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ae3c2adc1f0d1a2b33905452c9b9a645b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pre_swsh_derivative_tags_to_compute_for_t</b> = typename <a class="el" href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html">pre_swsh_derivative_tags_to_compute_for</a>&lt; Tag &gt;::type</td></tr>
<tr class="separator:ae3c2adc1f0d1a2b33905452c9b9a645b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a70495dd357c5c456b5ed2fd65cbcd2de"><td class="memTemplParams" colspan="2"><a id="a70495dd357c5c456b5ed2fd65cbcd2de"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a70495dd357c5c456b5ed2fd65cbcd2de"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>single_swsh_derivative_tags_to_compute_for_t</b> = typename <a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a>&lt; Tag &gt;::type</td></tr>
<tr class="separator:a70495dd357c5c456b5ed2fd65cbcd2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a85d532741987969e9994e20db3c5eba8"><td class="memTemplParams" colspan="2"><a id="a85d532741987969e9994e20db3c5eba8"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a85d532741987969e9994e20db3c5eba8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>second_swsh_derivative_tags_to_compute_for_t</b> = typename <a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a>&lt; Tag &gt;::type</td></tr>
<tr class="separator:a85d532741987969e9994e20db3c5eba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6595b69e95906157b1c6016c33ba476f"><td class="memItemLeft" align="right" valign="top"><a id="a6595b69e95906157b1c6016c33ba476f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>trigonometric_functions_on_swsh_collocation</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; cos_phi, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; cos_theta, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; sin_phi, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; sin_theta, const size_t l_max) noexcept</td></tr>
<tr class="separator:a6595b69e95906157b1c6016c33ba476f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f8c47a4799c51b1496f0398940724d"><td class="memItemLeft" align="right" valign="top"><a id="a49f8c47a4799c51b1496f0398940724d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_to_spherical_coordinates_and_jacobians</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; unit_cartesian_coords, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; SphericaliCartesianJ *&gt; cartesian_to_spherical_jacobian, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CartesianiSphericalJ *&gt; inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_theta, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_theta, const double extraction_radius) noexcept</td></tr>
<tr class="separator:a49f8c47a4799c51b1496f0398940724d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae947fb6c0a547cc35e71274e7d87d9dc"><td class="memItemLeft" align="right" valign="top"><a id="ae947fb6c0a547cc35e71274e7d87d9dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_spatial_metric_and_derivatives_from_modes</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; inverse_cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ijj&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; d_cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; dt_cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt; interpolation_modal_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; interpolation_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; eth_buffer, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_spatial_metric_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const size_t l_max) noexcept</td></tr>
<tr class="separator:ae947fb6c0a547cc35e71274e7d87d9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2500ded5f993e6317fca9060db3119c"><td class="memItemLeft" align="right" valign="top"><a id="ab2500ded5f993e6317fca9060db3119c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_shift_and_derivatives_from_modes</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; cartesian_shift, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; d_cartesian_shift, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; dt_cartesian_shift, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt; interpolation_modal_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; interpolation_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; eth_buffer, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_shift_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const size_t l_max) noexcept</td></tr>
<tr class="separator:ab2500ded5f993e6317fca9060db3119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb066eb74d86972106c1977abf0584bc"><td class="memItemLeft" align="right" valign="top"><a id="acb066eb74d86972106c1977abf0584bc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_lapse_and_derivatives_from_modes</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; cartesian_lapse, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; d_cartesian_lapse, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; dt_cartesian_lapse, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt; interpolation_modal_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; interpolation_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; eth_buffer, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dr_lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dt_lapse_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const size_t l_max) noexcept</td></tr>
<tr class="separator:acb066eb74d86972106c1977abf0584bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa80f69c55e8c52c6523ad943c28a046"><td class="memItemLeft" align="right" valign="top"><a id="aaa80f69c55e8c52c6523ad943c28a046"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>null_metric_and_derivative</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; du_null_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; null_metric, const SphericaliCartesianJ &amp;cartesian_to_spherical_jacobian, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric) noexcept</td></tr>
<tr class="separator:aaa80f69c55e8c52c6523ad943c28a046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90364dc4afb3dc5ca2a26e9885bb7153"><td class="memItemLeft" align="right" valign="top"><a id="a90364dc4afb3dc5ca2a26e9885bb7153"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>worldtube_normal_and_derivatives</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; worldtube_normal, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; dt_worldtube_normal, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_theta, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_theta, const tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;inverse_spatial_metric) noexcept</td></tr>
<tr class="separator:a90364dc4afb3dc5ca2a26e9885bb7153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bef9490b91f740d9d23bab51f12a8d"><td class="memItemLeft" align="right" valign="top"><a id="aa6bef9490b91f740d9d23bab51f12a8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>null_vector_l_and_derivatives</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; du_null_l, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; null_l, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_worldtube_normal, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;dt_lapse, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_shift, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;lapse, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;shift, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;worldtube_normal) noexcept</td></tr>
<tr class="separator:aa6bef9490b91f740d9d23bab51f12a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec134cf5fdf1ed8cff802b25b59f6c1"><td class="memItemLeft" align="right" valign="top"><a id="abec134cf5fdf1ed8cff802b25b59f6c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dlambda_null_metric_and_inverse</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; dlambda_null_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; dlambda_inverse_null_metric, const AngulariCartesianA &amp;angular_d_null_l, const SphericaliCartesianJ &amp;cartesian_to_spherical_jacobian, const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;phi, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;du_null_l, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;null_l, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric) noexcept</td></tr>
<tr class="separator:abec134cf5fdf1ed8cff802b25b59f6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde14463b762d34a5f272948b1428518"><td class="memItemLeft" align="right" valign="top"><a id="acde14463b762d34a5f272948b1428518"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bondi_r</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; bondi_r, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;null_metric) noexcept</td></tr>
<tr class="separator:acde14463b762d34a5f272948b1428518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aea52b9603e24b0a310a6cbdd11fff"><td class="memItemLeft" align="right" valign="top"><a id="a03aea52b9603e24b0a310a6cbdd11fff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>d_bondi_r</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const size_t l_max) noexcept</td></tr>
<tr class="separator:a03aea52b9603e24b0a310a6cbdd11fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf5dec8b82f1089fdb12c0e74e52e73"><td class="memItemLeft" align="right" valign="top"><a id="aadf5dec8b82f1089fdb12c0e74e52e73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dyads</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; down_dyad, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; up_dyad) noexcept</td></tr>
<tr class="separator:aadf5dec8b82f1089fdb12c0e74e52e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d0eabcb52eb98e111e2b4af3e564e6"><td class="memItemLeft" align="right" valign="top"><a id="ae3d0eabcb52eb98e111e2b4af3e564e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>beta_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; beta, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r) noexcept</td></tr>
<tr class="separator:ae3d0eabcb52eb98e111e2b4af3e564e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af759aa6886d4cd625700a3536d13ba03"><td class="memItemLeft" align="right" valign="top"><a id="af759aa6886d4cd625700a3536d13ba03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bondi_u_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; bondi_u, const tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric) noexcept</td></tr>
<tr class="separator:af759aa6886d4cd625700a3536d13ba03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6519b360d412fde440bebf432563e369"><td class="memItemLeft" align="right" valign="top"><a id="a6519b360d412fde440bebf432563e369"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bondi_w_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; bondi_w, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r) noexcept</td></tr>
<tr class="separator:a6519b360d412fde440bebf432563e369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d0426a73fd9ae29dc63de9ad973313"><td class="memItemLeft" align="right" valign="top"><a id="a09d0426a73fd9ae29dc63de9ad973313"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bondi_j_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; *&gt; bondi_j, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="separator:a09d0426a73fd9ae29dc63de9ad973313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fe5ef2289f4beb699111aa06b8f3ec"><td class="memItemLeft" align="right" valign="top"><a id="a69fe5ef2289f4beb699111aa06b8f3ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dr_bondi_j</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; *&gt; dr_bondi_j, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; denominator_buffer, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="separator:a69fe5ef2289f4beb699111aa06b8f3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25ef231395af42e5901a61ce860516f"><td class="memItemLeft" align="right" valign="top"><a id="aa25ef231395af42e5901a61ce860516f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>d2lambda_bondi_r</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; d2lambda_bondi_r, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;dr_bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r) noexcept</td></tr>
<tr class="separator:aa25ef231395af42e5901a61ce860516f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201dc27c47a1cdda7e1b2768a2844957"><td class="memItemLeft" align="right" valign="top"><a id="a201dc27c47a1cdda7e1b2768a2844957"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bondi_q_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; bondi_q, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; dr_bondi_u, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;d2lambda_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_inverse_null_metric, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;angular_d_dlambda_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; &amp;bondi_u) noexcept</td></tr>
<tr class="separator:a201dc27c47a1cdda7e1b2768a2844957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951c9ab915bd74cdb12b34f68319a57f"><td class="memItemLeft" align="right" valign="top"><a id="a951c9ab915bd74cdb12b34f68319a57f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bondi_h_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; *&gt; bondi_h, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="separator:a951c9ab915bd74cdb12b34f68319a57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5a74b05167d0ff680b4b44a59b8b01"><td class="memItemLeft" align="right" valign="top"><a id="afc5a74b05167d0ff680b4b44a59b8b01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>du_j_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; *&gt; du_bondi_j, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="separator:afc5a74b05167d0ff680b4b44a59b8b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b43a20534ee24795c4b343c8045c39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a87b43a20534ee24795c4b343c8045c39">trigonometric_functions_on_swsh_collocation</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; cos_phi, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; cos_theta, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; sin_phi, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; sin_theta, size_t l_max) noexcept</td></tr>
<tr class="memdesc:a87b43a20534ee24795c4b343c8045c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the collocation values for \(\cos(\phi)\), \(\cos(\theta)\), \(\sin(\phi)\), and \(\sin(\theta)\), returned by <code>not_null</code> pointer in that order.  <a href="#a87b43a20534ee24795c4b343c8045c39">More...</a><br /></td></tr>
<tr class="separator:a87b43a20534ee24795c4b343c8045c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d3f27158f32c4defb7c39f73f20fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a29d3f27158f32c4defb7c39f73f20fbb">cartesian_to_spherical_coordinates_and_jacobians</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; unit_cartesian_coords, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; SphericaliCartesianJ *&gt; cartesian_to_spherical_jacobian, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CartesianiSphericalJ *&gt; inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_theta, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_theta, double extraction_radius) noexcept</td></tr>
<tr class="memdesc:a29d3f27158f32c4defb7c39f73f20fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates both the Jacobian and inverse Jacobian between Cartesian and spherical coordinates, and the coordinates themselves.  <a href="#a29d3f27158f32c4defb7c39f73f20fbb">More...</a><br /></td></tr>
<tr class="separator:a29d3f27158f32c4defb7c39f73f20fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1291dde2243899df101f1d0354091900"><td class="memItemLeft" align="right" valign="top"><a id="a1291dde2243899df101f1d0354091900"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_spatial_metric_and_derivatives_from_modes</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; inverse_cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ijj&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; d_cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; dt_cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt; interpolation_modal_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; interpolation_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; eth_buffer, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_spatial_metric_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, size_t l_max) noexcept</td></tr>
<tr class="separator:a1291dde2243899df101f1d0354091900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3339940de1625fdca053abe920eb7a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a3339940de1625fdca053abe920eb7a46">cartesian_shift_and_derivatives_from_modes</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; cartesian_shift, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; d_cartesian_shift, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; dt_cartesian_shift, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt; interpolation_modal_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; interpolation_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; eth_buffer, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_shift_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, size_t l_max) noexcept</td></tr>
<tr class="memdesc:a3339940de1625fdca053abe920eb7a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\beta^{i}\), \(\partial_i \beta^{j}\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities.  <a href="#a3339940de1625fdca053abe920eb7a46">More...</a><br /></td></tr>
<tr class="separator:a3339940de1625fdca053abe920eb7a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ef8d66e40c8f913868b7057ec83566"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ad1ef8d66e40c8f913868b7057ec83566">cartesian_lapse_and_derivatives_from_modes</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; cartesian_lapse, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; d_cartesian_lapse, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; dt_cartesian_lapse, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt; interpolation_modal_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; interpolation_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; eth_buffer, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dr_lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dt_lapse_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, size_t l_max) noexcept</td></tr>
<tr class="memdesc:ad1ef8d66e40c8f913868b7057ec83566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\alpha\), \(\partial_i \alpha\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities.  <a href="#ad1ef8d66e40c8f913868b7057ec83566">More...</a><br /></td></tr>
<tr class="separator:ad1ef8d66e40c8f913868b7057ec83566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93909e253772bbdfd7a226b3bd6ea07a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a93909e253772bbdfd7a226b3bd6ea07a">null_metric_and_derivative</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; du_null_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; null_metric, const SphericaliCartesianJ &amp;cartesian_to_spherical_jacobian, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric) noexcept</td></tr>
<tr class="memdesc:a93909e253772bbdfd7a226b3bd6ea07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spacetime metric and its first derivative in the intermediate radial null coordinates.  <a href="#a93909e253772bbdfd7a226b3bd6ea07a">More...</a><br /></td></tr>
<tr class="separator:a93909e253772bbdfd7a226b3bd6ea07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c376c6944c906be71dafc0a37761a45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9c376c6944c906be71dafc0a37761a45">worldtube_normal_and_derivatives</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; worldtube_normal, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; dt_worldtube_normal, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_theta, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_theta, const tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;inverse_spatial_metric) noexcept</td></tr>
<tr class="memdesc:a9c376c6944c906be71dafc0a37761a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spatial unit normal vector \(s^i\) to the spherical worldtube surface and its first time derivative.  <a href="#a9c376c6944c906be71dafc0a37761a45">More...</a><br /></td></tr>
<tr class="separator:a9c376c6944c906be71dafc0a37761a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0fbfceb7e1252112260c1d02a09961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9f0fbfceb7e1252112260c1d02a09961">null_vector_l_and_derivatives</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; du_null_l, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; null_l, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_worldtube_normal, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;dt_lapse, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_shift, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;lapse, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;shift, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;worldtube_normal) noexcept</td></tr>
<tr class="memdesc:a9f0fbfceb7e1252112260c1d02a09961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the null 4-vector \(l^\mu\) on the worldtube surface that is to be used as the CCE hypersurface generator, and the first time derivative \(\partial_u l^\mu\).  <a href="#a9f0fbfceb7e1252112260c1d02a09961">More...</a><br /></td></tr>
<tr class="separator:a9f0fbfceb7e1252112260c1d02a09961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb617b56d6ee954cd3e391c6cf5d20c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#abb617b56d6ee954cd3e391c6cf5d20c4">dlambda_null_metric_and_inverse</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; dlambda_null_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; dlambda_inverse_null_metric, const AngulariCartesianA &amp;angular_d_null_l, const SphericaliCartesianJ &amp;cartesian_to_spherical_jacobian, const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;phi, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;du_null_l, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;null_l, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric) noexcept</td></tr>
<tr class="memdesc:abb617b56d6ee954cd3e391c6cf5d20c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial derivative of the spacetime metric and inverse spacetime metric in the intermediate null radial coordinates with respect to the null generator \(l^\mu\).  <a href="#abb617b56d6ee954cd3e391c6cf5d20c4">More...</a><br /></td></tr>
<tr class="separator:abb617b56d6ee954cd3e391c6cf5d20c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f79ce9e6a9c5aab393b09cb29139fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a8f79ce9e6a9c5aab393b09cb29139fb6">bondi_r</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; bondi_r, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;null_metric) noexcept</td></tr>
<tr class="memdesc:a8f79ce9e6a9c5aab393b09cb29139fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Bondi radius of the worldtube.  <a href="#a8f79ce9e6a9c5aab393b09cb29139fb6">More...</a><br /></td></tr>
<tr class="separator:a8f79ce9e6a9c5aab393b09cb29139fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4badb01ac37f2d368a259ef85fb823e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ac4badb01ac37f2d368a259ef85fb823e">d_bondi_r</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, size_t l_max) noexcept</td></tr>
<tr class="memdesc:ac4badb01ac37f2d368a259ef85fb823e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the full 4-dimensional partial of the Bondi radius with respect to the intermediate null coordinates.  <a href="#ac4badb01ac37f2d368a259ef85fb823e">More...</a><br /></td></tr>
<tr class="separator:ac4badb01ac37f2d368a259ef85fb823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6b36590b1996c6af1da396719c0a1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aef6b36590b1996c6af1da396719c0a1d">dyads</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; down_dyad, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; up_dyad) noexcept</td></tr>
<tr class="memdesc:aef6b36590b1996c6af1da396719c0a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex angular dyads used to define the spin-weighted scalars in the CCE system.  <a href="#aef6b36590b1996c6af1da396719c0a1d">More...</a><br /></td></tr>
<tr class="separator:aef6b36590b1996c6af1da396719c0a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5158db4a78e3a71c17cad64f08d9fa27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a5158db4a78e3a71c17cad64f08d9fa27">beta_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; beta, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r) noexcept</td></tr>
<tr class="memdesc:a5158db4a78e3a71c17cad64f08d9fa27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the \(\beta\) (lapse) function for the CCE Bondi-like metric.  <a href="#a5158db4a78e3a71c17cad64f08d9fa27">More...</a><br /></td></tr>
<tr class="separator:a5158db4a78e3a71c17cad64f08d9fa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cbd6be25c04fc1aad04d709d8c889e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ac3cbd6be25c04fc1aad04d709d8c889e">bondi_u_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; bondi_u, const tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric) noexcept</td></tr>
<tr class="memdesc:ac3cbd6be25c04fc1aad04d709d8c889e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the \(U\) (shift) function for the CCE Bondi-like metric.  <a href="#ac3cbd6be25c04fc1aad04d709d8c889e">More...</a><br /></td></tr>
<tr class="separator:ac3cbd6be25c04fc1aad04d709d8c889e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693628f0ebcc0e9119e726f571241751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a693628f0ebcc0e9119e726f571241751">bondi_w_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; bondi_w, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r) noexcept</td></tr>
<tr class="memdesc:a693628f0ebcc0e9119e726f571241751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the \(W\) (mass aspect) function for the CCE Bondi-like metric.  <a href="#a693628f0ebcc0e9119e726f571241751">More...</a><br /></td></tr>
<tr class="separator:a693628f0ebcc0e9119e726f571241751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f24b835ac5c120ea937779b9eefced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a95f24b835ac5c120ea937779b9eefced">bondi_j_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; *&gt; bondi_j, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="memdesc:a95f24b835ac5c120ea937779b9eefced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the \(J\) (intuitively similar to the transverse-traceless part of the angular metric) function for the CCE Bondi-like metric.  <a href="#a95f24b835ac5c120ea937779b9eefced">More...</a><br /></td></tr>
<tr class="separator:a95f24b835ac5c120ea937779b9eefced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260cf3ab8aea0f27c64269e8b5ec58c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a260cf3ab8aea0f27c64269e8b5ec58c0">dr_bondi_j</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; *&gt; dr_bondi_j, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; denominator_buffer, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="memdesc:a260cf3ab8aea0f27c64269e8b5ec58c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the radial derivative of the angular metric spin-weighted scalar \(\partial_r J\) in the CCE Bondi-like metric.  <a href="#a260cf3ab8aea0f27c64269e8b5ec58c0">More...</a><br /></td></tr>
<tr class="separator:a260cf3ab8aea0f27c64269e8b5ec58c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac07448b0246c2878e13b941fd3160b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9ac07448b0246c2878e13b941fd3160b">d2lambda_bondi_r</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; d2lambda_bondi_r, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;dr_bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r) noexcept</td></tr>
<tr class="memdesc:a9ac07448b0246c2878e13b941fd3160b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the second derivative of the Bondi radius with respect to the intermediate null coordinate radius \(\partial_\lambda^2 r\).  <a href="#a9ac07448b0246c2878e13b941fd3160b">More...</a><br /></td></tr>
<tr class="separator:a9ac07448b0246c2878e13b941fd3160b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b78e385acc19e7657db3431a36bee40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a8b78e385acc19e7657db3431a36bee40">bondi_q_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; bondi_q, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; dr_bondi_u, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;d2lambda_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_inverse_null_metric, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;angular_d_dlambda_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; &amp;bondi_u) noexcept</td></tr>
<tr class="memdesc:a8b78e385acc19e7657db3431a36bee40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Bondi metric contribution \(Q\) (radial derivative of shift).  <a href="#a8b78e385acc19e7657db3431a36bee40">More...</a><br /></td></tr>
<tr class="separator:a8b78e385acc19e7657db3431a36bee40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672ecef74fb583929a9446b542500ad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a672ecef74fb583929a9446b542500ad4">bondi_h_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; *&gt; bondi_h, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="memdesc:a672ecef74fb583929a9446b542500ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Bondi metric contribution \((\partial_u J)_{y} \equiv H\) (the retarded time derivative evaluated at fixed $y$ coordinate) on the worldtube boundary.  <a href="#a672ecef74fb583929a9446b542500ad4">More...</a><br /></td></tr>
<tr class="separator:a672ecef74fb583929a9446b542500ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c953959000b0a4e3dc411cfab510bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a7c953959000b0a4e3dc411cfab510bb6">du_j_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; *&gt; du_bondi_j, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="memdesc:a7c953959000b0a4e3dc411cfab510bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Bondi metric contribution \((\partial_u J)_r\) (the retarded time derivative at fixed coordinate $r$) on the worldtube boundary.  <a href="#a7c953959000b0a4e3dc411cfab510bb6">More...</a><br /></td></tr>
<tr class="separator:a7c953959000b0a4e3dc411cfab510bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6894f695b6f0ac58e91ca664988a8bba"><td class="memTemplParams" colspan="2">template&lt;typename DataBoxTagList &gt; </td></tr>
<tr class="memitem:a6894f695b6f0ac58e91ca664988a8bba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a6894f695b6f0ac58e91ca664988a8bba">create_bondi_boundary_data</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classdb_1_1DataBox.html">db::DataBox</a>&lt; DataBoxTagList &gt; *&gt; bondi_boundary_data, const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;phi, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;pi, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const double extraction_radius, const size_t l_max) noexcept</td></tr>
<tr class="memdesc:a6894f695b6f0ac58e91ca664988a8bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the worldtube data from generalized harmonic quantities to desired Bondi quantities, placing the result in the passed <a class="el" href="group__DataBoxGroup.html">DataBox</a>.  <a href="#a6894f695b6f0ac58e91ca664988a8bba">More...</a><br /></td></tr>
<tr class="separator:a6894f695b6f0ac58e91ca664988a8bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd886d931b6038954d3f405cdc391b1"><td class="memTemplParams" colspan="2">template&lt;typename DataBoxTagList &gt; </td></tr>
<tr class="memitem:a5bd886d931b6038954d3f405cdc391b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a5bd886d931b6038954d3f405cdc391b1">create_bondi_boundary_data</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classdb_1_1DataBox.html">db::DataBox</a>&lt; DataBoxTagList &gt; *&gt; bondi_boundary_data, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_spatial_metric_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_shift_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dt_lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dr_lapse_coefficients, const double extraction_radius, const size_t l_max) noexcept</td></tr>
<tr class="memdesc:a5bd886d931b6038954d3f405cdc391b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the worldtube data from modal metric components and derivatives to desired Bondi quantities, placing the result in the passed <a class="el" href="group__DataBoxGroup.html">DataBox</a>.  <a href="#a5bd886d931b6038954d3f405cdc391b1">More...</a><br /></td></tr>
<tr class="separator:a5bd886d931b6038954d3f405cdc391b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d126eba6a887771c53fc28f55eb36e6"><td class="memItemLeft" align="right" valign="top"><a id="a7d126eba6a887771c53fc28f55eb36e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>logical_partial_directional_derivative_of_complex</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> *&gt; d_u, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;mesh, const size_t dimension_to_differentiate) noexcept</td></tr>
<tr class="separator:a7d126eba6a887771c53fc28f55eb36e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246fe522bad41a8830e114c7d5e136e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a246fe522bad41a8830e114c7d5e136e3">logical_partial_directional_derivative_of_complex</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> *&gt; d_u, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;mesh, size_t dimension_to_differentiate) noexcept</td></tr>
<tr class="memdesc:a246fe522bad41a8830e114c7d5e136e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial derivative along a particular direction determined by the <code>dimension_to_differentiate</code>. The input <code>u</code> is differentiated with the spectral matrix and the solution is placed in <code>d_u</code>.  <a href="#a246fe522bad41a8830e114c7d5e136e3">More...</a><br /></td></tr>
<tr class="separator:a246fe522bad41a8830e114c7d5e136e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af367dfeb1f3ee40aca23c628e9809ac1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#af367dfeb1f3ee40aca23c628e9809ac1">precomputed_cce_q_integrator</a> (size_t number_of_radial_grid_points) noexcept</td></tr>
<tr class="memdesc:af367dfeb1f3ee40aca23c628e9809ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to a lazily cached integration matrix for the \(Q\) and \(W\) equations in CCE hypersurface evaluation.  <a href="#af367dfeb1f3ee40aca23c628e9809ac1">More...</a><br /></td></tr>
<tr class="separator:af367dfeb1f3ee40aca23c628e9809ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca83d5070828ccc7669f4a6b2dcbb634"><td class="memItemLeft" align="right" valign="top"><a id="aca83d5070828ccc7669f4a6b2dcbb634"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>radial_integrate_cce_pole_equations</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> *&gt; integral_result, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;pole_of_integrand, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;regular_integrand, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;boundary, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;one_minus_y, const size_t l_max, const size_t number_of_radial_points) noexcept</td></tr>
<tr class="separator:aca83d5070828ccc7669f4a6b2dcbb634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8001cac388464a9afee45fe2787acb3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a8001cac388464a9afee45fe2787acb3a">radial_integrate_cce_pole_equations</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> *&gt; integral_result, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;pole_of_integrand, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;regular_integrand, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;boundary, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;one_minus_y, size_t l_max, size_t number_of_radial_points) noexcept</td></tr>
<tr class="memdesc:a8001cac388464a9afee45fe2787acb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function for evaluating the \(Q\) and \(W\) hypersurface integrals during CCE evolution.  <a href="#a8001cac388464a9afee45fe2787acb3a">More...</a><br /></td></tr>
<tr class="separator:a8001cac388464a9afee45fe2787acb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9aaac2c0f9818a9f6c9b1f311a373c5"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class BoundaryPrefix, typename DataBoxType &gt; </td></tr>
<tr class="memitem:ad9aaac2c0f9818a9f6c9b1f311a373c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ad9aaac2c0f9818a9f6c9b1f311a373c5">mutate_all_precompute_cce_dependencies</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBoxType *&gt; box) noexcept</td></tr>
<tr class="memdesc:ad9aaac2c0f9818a9f6c9b1f311a373c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience routine for computing all of the CCE inputs to integrand computation that do not depend on intermediate integrand results. It should be executed before moving through the hierarchy of integrands.  <a href="#ad9aaac2c0f9818a9f6c9b1f311a373c5">More...</a><br /></td></tr>
<tr class="separator:ad9aaac2c0f9818a9f6c9b1f311a373c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea7655c4828aea4ec5a29941d709860"><td class="memTemplParams" colspan="2">template&lt;typename BondiValueTag , typename DataBoxType &gt; </td></tr>
<tr class="memitem:a0ea7655c4828aea4ec5a29941d709860"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a0ea7655c4828aea4ec5a29941d709860">mutate_all_pre_swsh_derivatives_for_tag</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBoxType *&gt; box) noexcept</td></tr>
<tr class="memdesc:a0ea7655c4828aea4ec5a29941d709860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the set of inputs to the CCE integrand for <code>BondiValueTag</code> that do not involve spin-weighted angular differentiation.  <a href="#a0ea7655c4828aea4ec5a29941d709860">More...</a><br /></td></tr>
<tr class="separator:a0ea7655c4828aea4ec5a29941d709860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea62aa3f794b4db28493d91fa620dff0"><td class="memTemplParams" colspan="2"><a id="aea62aa3f794b4db28493d91fa620dff0"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:aea62aa3f794b4db28493d91fa620dff0"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aea62aa3f794b4db28493d91fa620dff0">dataset_label_for_tag</a> () noexcept</td></tr>
<tr class="memdesc:aea62aa3f794b4db28493d91fa620dff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dataset string associated with each scalar that will be output in the reduced set of SpEC-like worldtube boundary data. <br /></td></tr>
<tr class="separator:aea62aa3f794b4db28493d91fa620dff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88dfe524596d0b75563d6847440f90f3"><td class="memTemplParams" colspan="2"><a id="a88dfe524596d0b75563d6847440f90f3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a88dfe524596d0b75563d6847440f90f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::BondiBeta &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:a88dfe524596d0b75563d6847440f90f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae883685ec4399565f0e8249ea137f28a"><td class="memTemplParams" colspan="2"><a id="ae883685ec4399565f0e8249ea137f28a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae883685ec4399565f0e8249ea137f28a"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::BondiU &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:ae883685ec4399565f0e8249ea137f28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b57bbdc7fe9c1e0922b3e51f0bfbc2"><td class="memTemplParams" colspan="2"><a id="a36b57bbdc7fe9c1e0922b3e51f0bfbc2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a36b57bbdc7fe9c1e0922b3e51f0bfbc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::BondiQ &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:a36b57bbdc7fe9c1e0922b3e51f0bfbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2835060732d66cc0d7b11e2acd4f3dfa"><td class="memTemplParams" colspan="2"><a id="a2835060732d66cc0d7b11e2acd4f3dfa"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2835060732d66cc0d7b11e2acd4f3dfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::BondiW &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:a2835060732d66cc0d7b11e2acd4f3dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6762043acd3580c812dbebb326f125b4"><td class="memTemplParams" colspan="2"><a id="a6762043acd3580c812dbebb326f125b4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6762043acd3580c812dbebb326f125b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::BondiJ &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:a6762043acd3580c812dbebb326f125b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3ed8eee465fac8249917d48b32dd35"><td class="memTemplParams" colspan="2"><a id="a5b3ed8eee465fac8249917d48b32dd35"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5b3ed8eee465fac8249917d48b32dd35"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::Dr&lt; Cce::Tags::BondiJ &gt; &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:a5b3ed8eee465fac8249917d48b32dd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e4cbef470d91d8ff8cefbc08dd581f"><td class="memTemplParams" colspan="2"><a id="ae5e4cbef470d91d8ff8cefbc08dd581f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae5e4cbef470d91d8ff8cefbc08dd581f"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::Du&lt; Cce::Tags::BondiJ &gt; &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:ae5e4cbef470d91d8ff8cefbc08dd581f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3757069588a164d737303fd1f558a74"><td class="memTemplParams" colspan="2"><a id="aa3757069588a164d737303fd1f558a74"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa3757069588a164d737303fd1f558a74"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::BondiR &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:aa3757069588a164d737303fd1f558a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8b3e7858bbb3e16ea6d7aa5571b347"><td class="memTemplParams" colspan="2"><a id="a6d8b3e7858bbb3e16ea6d7aa5571b347"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6d8b3e7858bbb3e16ea6d7aa5571b347"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::Du&lt; Cce::Tags::BondiR &gt; &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:a6d8b3e7858bbb3e16ea6d7aa5571b347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94ac68cc31088c9f0eee0c0a6954727"><td class="memItemLeft" align="right" valign="top"><a id="aa94ac68cc31088c9f0eee0c0a6954727"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_spatial_metric_and_derivatives_from_unnormalized_spec_modes</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; inverse_cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ijj&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; d_cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; dt_cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt; interpolation_modal_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; interpolation_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; eth_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; radial_correction_factor, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_spatial_metric_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;unit_cartesian_coords, const size_t l_max) noexcept</td></tr>
<tr class="separator:aa94ac68cc31088c9f0eee0c0a6954727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da63dae3c81b79e9015505fa0678620"><td class="memItemLeft" align="right" valign="top"><a id="a5da63dae3c81b79e9015505fa0678620"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_shift_and_derivatives_from_unnormalized_spec_modes</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; cartesian_shift, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; d_cartesian_shift, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; dt_cartesian_shift, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt; interpolation_modal_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; interpolation_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; eth_buffer, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_shift_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;radial_derivative_correction_factor, const size_t l_max) noexcept</td></tr>
<tr class="separator:a5da63dae3c81b79e9015505fa0678620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6121ef89e75ee7f1aad1b5131c81e8"><td class="memItemLeft" align="right" valign="top"><a id="add6121ef89e75ee7f1aad1b5131c81e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_lapse_and_derivatives_from_unnormalized_spec_modes</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; cartesian_lapse, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; d_cartesian_lapse, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; dt_cartesian_lapse, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt; interpolation_modal_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; interpolation_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; eth_buffer, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dr_lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dt_lapse_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;radial_derivative_correction_factor, const size_t l_max) noexcept</td></tr>
<tr class="separator:add6121ef89e75ee7f1aad1b5131c81e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7d01247120197882afee5462328f30"><td class="memItemLeft" align="right" valign="top"><a id="a5a7d01247120197882afee5462328f30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_spatial_metric_and_derivatives_from_unnormalized_spec_modes</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; inverse_cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ijj&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; d_cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; dt_cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt; interpolation_modal_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; interpolation_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; eth_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; radial_correction_factor, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_spatial_metric_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;unit_cartesian_coords, size_t l_max) noexcept</td></tr>
<tr class="separator:a5a7d01247120197882afee5462328f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4a0dc80871e01480b80b600f97d2c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a0b4a0dc80871e01480b80b600f97d2c8">cartesian_shift_and_derivatives_from_unnormalized_spec_modes</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; cartesian_shift, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; d_cartesian_shift, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; dt_cartesian_shift, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt; interpolation_modal_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; interpolation_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; eth_buffer, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_shift_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;radial_derivative_correction_factor, size_t l_max) noexcept</td></tr>
<tr class="memdesc:a0b4a0dc80871e01480b80b600f97d2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\beta^{i}\), \(\partial_i \beta^{j}\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities.  <a href="#a0b4a0dc80871e01480b80b600f97d2c8">More...</a><br /></td></tr>
<tr class="separator:a0b4a0dc80871e01480b80b600f97d2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2cc910c64bac7ada0a5ab1daef4720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#adf2cc910c64bac7ada0a5ab1daef4720">cartesian_lapse_and_derivatives_from_unnormalized_spec_modes</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; cartesian_lapse, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; d_cartesian_lapse, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; dt_cartesian_lapse, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt; interpolation_modal_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt; interpolation_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt; eth_buffer, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dr_lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dt_lapse_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;radial_derivative_correction_factor, size_t l_max) noexcept</td></tr>
<tr class="memdesc:adf2cc910c64bac7ada0a5ab1daef4720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\alpha\), \(\partial_i \alpha\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities.  <a href="#adf2cc910c64bac7ada0a5ab1daef4720">More...</a><br /></td></tr>
<tr class="separator:adf2cc910c64bac7ada0a5ab1daef4720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19097e1f2633885d31d4f16bd305b1c"><td class="memTemplParams" colspan="2">template&lt;typename DataBoxTagList &gt; </td></tr>
<tr class="memitem:ab19097e1f2633885d31d4f16bd305b1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ab19097e1f2633885d31d4f16bd305b1c">create_bondi_boundary_data_from_unnormalized_spec_modes</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classdb_1_1DataBox.html">db::DataBox</a>&lt; DataBoxTagList &gt; *&gt; bondi_boundary_data, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_spatial_metric_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_shift_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dt_lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dr_lapse_coefficients, const double extraction_radius, const size_t l_max) noexcept</td></tr>
<tr class="memdesc:ab19097e1f2633885d31d4f16bd305b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the worldtube data from modal metric components and derivatives with incorrectly normalized radial derivatives from an old version of SpEC to desired Bondi quantities, placing the result in the passed <a class="el" href="group__DataBoxGroup.html">DataBox</a>.  <a href="#ab19097e1f2633885d31d4f16bd305b1c">More...</a><br /></td></tr>
<tr class="separator:ab19097e1f2633885d31d4f16bd305b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710c185e2efce13bd57e2414145c2172"><td class="memTemplParams" colspan="2">template&lt;typename BondiValueTag , typename DataBoxTagList &gt; </td></tr>
<tr class="memitem:a710c185e2efce13bd57e2414145c2172"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a710c185e2efce13bd57e2414145c2172">mutate_all_swsh_derivatives_for_tag</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classdb_1_1DataBox.html">db::DataBox</a>&lt; DataBoxTagList &gt; *&gt; box) noexcept</td></tr>
<tr class="memdesc:a710c185e2efce13bd57e2414145c2172"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine evaluates the set of inputs to the CCE integrand for <code>BondiValueTag</code> which are spin-weighted angular derivatives.  <a href="#a710c185e2efce13bd57e2414145c2172">More...</a><br /></td></tr>
<tr class="separator:a710c185e2efce13bd57e2414145c2172"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains functionality for Cauchy Characteristic Extraction. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a7dd34947472e61d70007727517310500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd34947472e61d70007727517310500">&#9670;&nbsp;</a></span>all_pre_swsh_derivative_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a7dd34947472e61d70007727517310500">Cce::all_pre_swsh_derivative_tags</a> = typedef tmpl::remove_duplicates&lt;tmpl::flatten&lt;tmpl::list&lt; tmpl::transform&lt; <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a>, tmpl::bind&lt; tmpl::list, <a class="el" href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html">pre_swsh_derivative_tags_to_compute_for</a>&lt;tmpl::_1&gt;, detail::additional_pre_swsh_derivative_tags_for&lt;tmpl::_1&gt; &gt;&gt;, <a class="el" href="namespaceCce.html#a9a0c1285825dea59ca2860b31e2c0672">all_pre_swsh_derivative_tags_for_scri</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the full set of tags needed as direct or indirect input to any <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations...">ComputeBondiIntegrand</a></code> that are computed any specialization of <code>ComputePreSwshDerivatives</code>. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities needed for a CCE computation or component. The data structures represented by these tags should each have size <code>number_of_radial_points * Spectral::Swsh::number_of_swsh_collocation_points(l_max)</code>. </p>

</div>
</div>
<a id="ad3f639bb3b07cc123bdf53c26dbf0fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f639bb3b07cc123bdf53c26dbf0fff">&#9670;&nbsp;</a></span>all_swsh_derivative_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#ad3f639bb3b07cc123bdf53c26dbf0fff">Cce::all_swsh_derivative_tags</a> = typedef tmpl::remove_duplicates&lt;tmpl::flatten&lt;tmpl::transform&lt; <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a>, tmpl::bind&lt;tmpl::list, <a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a>&lt;tmpl::_1&gt;, <a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html">second_swsh_derivative_tags_to_compute_for</a>&lt;tmpl::_1&gt; &gt;&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the set of tags computed by spin-weighted differentiation using utilities from the <code>Swsh</code> namespace. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities needed for a CCE computation or component. The data structures represented by these tags should each have size <code>number_of_radial_points * Spectral::Swsh::number_of_swsh_collocation_points(l_max)</code>. All of these tags (for a given integrated Bondi quantity) may be computed at once if using a <a class="el" href="group__DataBoxGroup.html">DataBox</a> using the template <code>mutate_all_swsh_derivatives_for_tag</code>. Individual tag computation is not provided in a convenient interface, as there is significant savings in aggregating spin-weighted differentiation steps. The full set of integrated Bondi quantities is available from the typelist <code>bondi_hypersurface_step_tags</code>. </p>

</div>
</div>
<a id="a9cbd52ad55ee87beb6abf5857c2db60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbd52ad55ee87beb6abf5857c2db60a">&#9670;&nbsp;</a></span>all_transform_buffer_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a9cbd52ad55ee87beb6abf5857c2db60a">Cce::all_transform_buffer_tags</a> = typedef tmpl::remove_duplicates&lt;tmpl::flatten&lt;tmpl::transform&lt; <a class="el" href="namespaceCce.html#ad3f639bb3b07cc123bdf53c26dbf0fff">all_swsh_derivative_tags</a>, tmpl::bind&lt;<a class="el" href="group__SwshGroup.html#ga3a19e1d6fbdabe80a1252971f6594cfb">Spectral::Swsh::coefficient_buffer_tags_for_derivative_tag</a>, tmpl::_1&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the full set of coefficient buffers needed to process all of the tags in <code>all_swsh_derivative_tags</code> using batch processing provided in <code>mutate_all_swsh_derivatives_for_tag</code>. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities needed for a CCE computation or component. The data structures represented by these tags should each have size <code>number_of_radial_points * Spectral::Swsh::size_of_libsharp_coefficient_vector(l_max)</code>. Providing buffers associated with these tags is necessary for the use of the aggregated computation <code>mutate_all_swsh_derivatives_for_tag</code>. </p>

</div>
</div>
<a id="a6aa380f6f1dc1109be44f9ddbac98652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa380f6f1dc1109be44f9ddbac98652">&#9670;&nbsp;</a></span>bondi_hypersurface_step_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">Cce::bondi_hypersurface_step_tags</a> = typedef tmpl::list&lt;<a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a>, <a class="el" href="structCce_1_1Tags_1_1BondiQ.html">Tags::BondiQ</a>, <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a>, <a class="el" href="structCce_1_1Tags_1_1BondiW.html">Tags::BondiW</a>, <a class="el" href="structCce_1_1Tags_1_1BondiH.html">Tags::BondiH</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The set of Bondi quantities computed by hypersurface step, in the required order of computation </p>

</div>
</div>
<a id="a393d5c196acb92779ba89acbc1fa686e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393d5c196acb92779ba89acbc1fa686e">&#9670;&nbsp;</a></span>integrand_temporary_tags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a393d5c196acb92779ba89acbc1fa686e">Cce::integrand_temporary_tags</a> = typedef typename <a class="el" href="structCce_1_1ComputeBondiIntegrand.html">ComputeBondiIntegrand</a>&lt;Tag&gt;::temporary_tags</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Metafunction that is a <code>tmpl::list</code> of the temporary tags taken by the <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations...">ComputeBondiIntegrand</a></code> computational struct. </p>

</div>
</div>
<a id="aa00307a414eb1f569706cb7d7449fa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00307a414eb1f569706cb7d7449fa4d">&#9670;&nbsp;</a></span>pre_computation_boundary_tags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class BoundaryPrefix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#aa00307a414eb1f569706cb7d7449fa4d">Cce::pre_computation_boundary_tags</a> = typedef tmpl::list&lt;BoundaryPrefix&lt;<a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a>&gt;, BoundaryPrefix&lt;<a class="el" href="structCce_1_1Tags_1_1DuRDividedByR.html">Tags::DuRDividedByR</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the set of <code>BoundaryValue</code> tags needed as an input to any of the template specializations of <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">PrecomputeCceDependencies</a></code>. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities necessary for a CCE computation or portion thereof. A container of these tags should have size <code>Spectral::Swsh::number_of_swsh_collocation_points(l_max)</code>. </p>

</div>
</div>
<a id="a7a4a1a7fe54a9f77fbf034fb95f46474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4a1a7fe54a9f77fbf034fb95f46474">&#9670;&nbsp;</a></span>pre_computation_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a7a4a1a7fe54a9f77fbf034fb95f46474">Cce::pre_computation_tags</a> = typedef tmpl::list&lt;<a class="el" href="structCce_1_1Tags_1_1EthRDividedByR.html">Tags::EthRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthEthRDividedByR.html">Tags::EthEthRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthEthbarRDividedByR.html">Tags::EthEthbarRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1BondiK.html">Tags::BondiK</a>, <a class="el" href="structCce_1_1Tags_1_1OneMinusY.html">Tags::OneMinusY</a>, <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the set of tags computed by the set of template specializations of <code>PrecomputeCceDepedencies</code>. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities needed for a CCE computation or component. The data structures represented by these tags should each have size <code>number_of_radial_points * Spectral::Swsh::number_of_swsh_collocation_points(l_max)</code>. All of these tags may be computed at once if using a <a class="el" href="group__DataBoxGroup.html">DataBox</a> using the template <code>mutate_all_precompute_cce_dependencies</code> or individually using the template specializations <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">PrecomputeCceDependencies</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>the tag <code><a class="el" href="structCce_1_1Tags_1_1DuRDividedByR.html" title="The value , where  is Bondi radius of the worldtube. ">Tags::DuRDividedByR</a></code> is omitted from this list because in the case where a gauge transformation must be applied, the time derivative quantities must wait until later in the computation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5158db4a78e3a71c17cad64f08d9fa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5158db4a78e3a71c17cad64f08d9fa27">&#9670;&nbsp;</a></span>beta_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::beta_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the \(\beta\) (lapse) function for the CCE Bondi-like metric. </p>
<h3>Details</h3>
<p>The Bondi-like metric has \(g^{u r} = - e^{2 \beta}\), and the value of \(\beta\) is obtained from the intermediate null metric by (see equation (51) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>) using:</p>
<p class="formulaDsp">
\[ \beta = -\frac{1}{2} \ln \partial_{\lambda} r \]
</p>
 
</div>
</div>
<a id="a672ecef74fb583929a9446b542500ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672ecef74fb583929a9446b542500ad4">&#9670;&nbsp;</a></span>bondi_h_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::bondi_h_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>bondi_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>du_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dyad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Bondi metric contribution \((\partial_u J)_{y} \equiv H\) (the retarded time derivative evaluated at fixed $y$ coordinate) on the worldtube boundary. </p>
<h3>Details</h3>
<p>The numerical time derivative (along the worldtube, rather than along the surface of constant Bondi \(r\)) is computed by (see equation (48) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>)</p>
<p class="formulaDsp">
\[ (\partial_u J)_y = \frac{1}{2 r^2} q^A q^B \partial_u g_{A B} - \frac{2 \partial_u r}{r} J \]
</p>
<dl class="section note"><dt>Note</dt><dd>There is the regrettable notation difference with the primary reference for these formulas <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a> in that we denote with \(H\) the time derivative at constant numerical radius, where <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a> uses \(H\) to denote the time derivative at constant Bondi radius. </dd></dl>

</div>
</div>
<a id="a95f24b835ac5c120ea937779b9eefced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f24b835ac5c120ea937779b9eefced">&#9670;&nbsp;</a></span>bondi_j_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::bondi_j_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dyad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the \(J\) (intuitively similar to the transverse-traceless part of the angular metric) function for the CCE Bondi-like metric. </p>
<h3>Details</h3>
<p>The Bondi-like metric has \(J = \frac{1}{2 r^2} q^A q^B g_{A B}\). This expression holds both for the right-hand side in the Bondi coordinates and for the right-hand side in the intermediate null coordinates (see equation (45) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>). </p>

</div>
</div>
<a id="a8b78e385acc19e7657db3431a36bee40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b78e385acc19e7657db3431a36bee40">&#9670;&nbsp;</a></span>bondi_q_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::bondi_q_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>bondi_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>dr_bondi_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d2lambda_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dlambda_inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dyad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>angular_d_dlambda_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Bondi metric contribution \(Q\) (radial derivative of shift). </p>
<h3>Details</h3>
<p>The definition of \(Q\) in terms of the Bondi metric components is</p>
<p class="formulaDsp">
\[ Q = q^A e^{-2 \beta} g_{A B} \partial_r U^B. \]
</p>
<p>$Q$ can be derived from the intermediate null metric quantities via (see equations (56) and (57) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>)</p>
<p class="formulaDsp">
\[ \partial_\lambda U = - \left(\partial_\lambda g^{\lambda A} + \frac{\partial_A \partial_\lambda r}{\partial_\lambda r} g^{A B} + \frac{\partial_B r}{\partial_\lambda r} \partial_\lambda g^{A B}\right) q_A + 2 \partial_\lambda \beta (U + g^{\lambda A} q_A) \]
</p>
<p>and</p>
<p class="formulaDsp">
\[ Q = r^2 (J \partial_\lambda \bar U + K \partial_\lambda U) \]
</p>
<p>also provided is \(\partial_r U\), which is separately useful to cache for other intermediate steps in the CCE computation. </p>

</div>
</div>
<a id="a8f79ce9e6a9c5aab393b09cb29139fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f79ce9e6a9c5aab393b09cb29139fb6">&#9670;&nbsp;</a></span>bondi_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::bondi_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>null_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Bondi radius of the worldtube. </p>
<h3>Details</h3>
<p>Note that unlike the Cauchy coordinate radius, the Bondi radius is not constant over the worldtube. Instead, it is obtained by the determinant of the angular part of the metric in the intermediate null coordinates (see <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>).</p>
<p class="formulaDsp">
\[ r = \left(\frac{\det g_{A B}}{ q_{A B}}\right)^{1/4}, \]
</p>
<p>where \(q_{A B}\) is the unit sphere metric. </p>

</div>
</div>
<a id="ac3cbd6be25c04fc1aad04d709d8c889e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cbd6be25c04fc1aad04d709d8c889e">&#9670;&nbsp;</a></span>bondi_u_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::bondi_u_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>bondi_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dyad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_null_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the \(U\) (shift) function for the CCE Bondi-like metric. </p>
<h3>Details</h3>
<p>The Bondi-like metric has \(g^{r A} = -e^{-2 \beta} U^A\), and the spin-weighted vector \(U = U^A q_A\). The value of \(U^A\) can be computed from the intermediate null metric quantities (see equation (54) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>) using:</p>
<p class="formulaDsp">
\[ U = -(\partial_\lambda r g^{\lambda A} + \partial_B r g^{A B}) q_A / \partial_\lambda r \]
</p>
 
</div>
</div>
<a id="a693628f0ebcc0e9119e726f571241751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693628f0ebcc0e9119e726f571241751">&#9670;&nbsp;</a></span>bondi_w_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::bondi_w_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>bondi_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the \(W\) (mass aspect) function for the CCE Bondi-like metric. </p>
<h3>Details</h3>
<p>The Bondi-like metric has \(g^{rr} = e^{-2 \beta}(1 + r W)\). The value of \(W\) can be computed from the null metric quantities (see equation (55) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>) using:</p>
<p class="formulaDsp">
\[ W = \frac{1}{r} \left(-1 + \frac{g^{\lambda \lambda} (\partial_\lambda r)^2 + 2 \partial_\lambda r \left(\partial_A r g^{\lambda A} - \partial_u r\right) + \partial_A r \partial_B r g^{A B}} {\partial_\lambda r}\right) \]
</p>
 
</div>
</div>
<a id="ad1ef8d66e40c8f913868b7057ec83566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ef8d66e40c8f913868b7057ec83566">&#9670;&nbsp;</a></span>cartesian_lapse_and_derivatives_from_modes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::cartesian_lapse_and_derivatives_from_modes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>cartesian_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>d_cartesian_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>dt_cartesian_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>interpolation_modal_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>interpolation_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>eth_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CartesianiSphericalJ &amp;&#160;</td>
          <td class="paramname"><em>inverse_cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute \(\alpha\), \(\partial_i \alpha\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities. </p>
<h3>Details</h3>
<p>This function interpolates the modes of input \(\alpha\), \(\partial_r \alpha\), and \(\partial_r \alpha\) to the libsharp-compatible grid. This function then applies the necessary jacobian factors and angular derivatives to determine the full \(\partial_i \alpha\). </p>

</div>
</div>
<a id="adf2cc910c64bac7ada0a5ab1daef4720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2cc910c64bac7ada0a5ab1daef4720">&#9670;&nbsp;</a></span>cartesian_lapse_and_derivatives_from_unnormalized_spec_modes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::cartesian_lapse_and_derivatives_from_unnormalized_spec_modes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>cartesian_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>d_cartesian_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>dt_cartesian_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>interpolation_modal_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>interpolation_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>eth_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CartesianiSphericalJ &amp;&#160;</td>
          <td class="paramname"><em>inverse_cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_derivative_correction_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute \(\alpha\), \(\partial_i \alpha\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities. </p>
<h3>Details</h3>
<p>This function will apply a correction factor associated with a SpEC bug. </p>

</div>
</div>
<a id="a3339940de1625fdca053abe920eb7a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3339940de1625fdca053abe920eb7a46">&#9670;&nbsp;</a></span>cartesian_shift_and_derivatives_from_modes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::cartesian_shift_and_derivatives_from_modes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>cartesian_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>d_cartesian_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>dt_cartesian_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>interpolation_modal_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>interpolation_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>eth_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CartesianiSphericalJ &amp;&#160;</td>
          <td class="paramname"><em>inverse_cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute \(\beta^{i}\), \(\partial_i \beta^{j}\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities. </p>
<h3>Details</h3>
<p>This function interpolates the modes of input \(\beta^i\), \(\partial_r \beta^i\), and \(\partial_r \beta^i\) to the libsharp-compatible grid. This function then applies the necessary jacobian factors and angular derivatives to determine the full \(\partial_i \beta^i\). </p>

</div>
</div>
<a id="a0b4a0dc80871e01480b80b600f97d2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4a0dc80871e01480b80b600f97d2c8">&#9670;&nbsp;</a></span>cartesian_shift_and_derivatives_from_unnormalized_spec_modes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::cartesian_shift_and_derivatives_from_unnormalized_spec_modes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>cartesian_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>d_cartesian_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>dt_cartesian_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>interpolation_modal_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>interpolation_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>eth_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CartesianiSphericalJ &amp;&#160;</td>
          <td class="paramname"><em>inverse_cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_derivative_correction_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute \(\beta^{i}\), \(\partial_i \beta^{j}\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities. </p>
<h3>Details</h3>
<p>This function will apply a correction factor associated with a SpEC bug. </p>

</div>
</div>
<a id="a29d3f27158f32c4defb7c39f73f20fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d3f27158f32c4defb7c39f73f20fbb">&#9670;&nbsp;</a></span>cartesian_to_spherical_coordinates_and_jacobians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::cartesian_to_spherical_coordinates_and_jacobians </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>unit_cartesian_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; SphericaliCartesianJ *&gt;&#160;</td>
          <td class="paramname"><em>cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CartesianiSphericalJ *&gt;&#160;</td>
          <td class="paramname"><em>inverse_cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>extraction_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates both the Jacobian and inverse Jacobian between Cartesian and spherical coordinates, and the coordinates themselves. </p>
<h3>Details</h3>
<p>The <code>cartesian_to_spherical_jacobian</code> is \(dx^i/d\tilde{x}^{\tilde j}\), where the Cartesian components are in order \(x^i = \{x, y, z\}\) and the spherical coordinates are \(\tilde{x}^{\tilde j} = \{r, \theta, \phi\}\). The Cartesian coordinates given are the standard unit sphere coordinates:</p>
<p class="formulaDsp">
\begin{align*} x &amp;= \cos(\phi) \sin(\theta)\\ y &amp;= \sin(\phi) \sin(\theta)\\ z &amp;= \cos(\theta) \end{align*}
</p>
<dl class="section note"><dt>Note</dt><dd>These Jacobians are adjusted to improve regularity near the pole, in particular the \(\partial \phi / \partial x^i\) components have been scaled by \(\sin \theta\) (omitting a \(1/\sin(\theta)\)) and the \(\partial x^i/\partial \phi\) components have been scaled by \(1/\sin(\theta)\) (omitting a \(\sin(\theta)\)). The reason is that in most careful calculations, these problematic sin factors can actually be omitted because they cancel. In cases where they are actually required, they must be put in by hand. </dd></dl>

</div>
</div>
<a id="a6894f695b6f0ac58e91ca664988a8bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6894f695b6f0ac58e91ca664988a8bba">&#9670;&nbsp;</a></span>create_bondi_boundary_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataBoxTagList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::create_bondi_boundary_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classdb_1_1DataBox.html">db::DataBox</a>&lt; DataBoxTagList &gt; *&gt;&#160;</td>
          <td class="paramname"><em>bondi_boundary_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>extraction_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process the worldtube data from generalized harmonic quantities to desired Bondi quantities, placing the result in the passed <a class="el" href="group__DataBoxGroup.html">DataBox</a>. </p>
<h3>Details</h3>
<p>The mathematics are a bit complicated for all of the coordinate transformations that are necessary to obtain the Bondi gauge quantities. For full mathematical details, see the documentation for functions in <code><a class="el" href="BoundaryData_8hpp_source.html">BoundaryData.hpp</a></code> and <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a> <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[9]</a>.</p>
<p>This function takes as input the full set of Generalized harmonic metric data on a two-dimensional surface of constant \(r\) and \(t\) in numerical coordinates.</p>
<p>Sufficient tags to provide full worldtube boundary data at a particular time are set in <code>bondi_boundary_data</code>. In particular, the set of tags in <code><a class="el" href="namespaceCce_1_1Tags.html#a7527c94f3bb08dd4124926b9ff41ebac" title="The collection of tags mutated by create_bondi_boundary_data ">Tags::characteristic_worldtube_boundary_tags</a></code> in the provided <a class="el" href="group__DataBoxGroup.html">DataBox</a> are assigned to the worldtube boundary values associated with the input metric components.</p>
<p>The majority of the mathematical transformations are implemented as a set of individual cascaded functions below. The details of the manipulations that are performed to the input data may be found in the individual functions themselves, which are called in the following order:</p><ul>
<li><code>trigonometric_functions_on_swsh_collocation()</code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#ga193f058861f7fbe61dd01e89ee9cbda0" title="Compute shift from spacetime metric and inverse spatial metric. ">gr::shift()</a></code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#gaca46ba0ea79929164495b2f587d40288" title="Compute lapse from shift and spacetime metric. ">gr::lapse()</a></code></li>
<li><code>worldtube_normal_and_derivatives()</code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#ga6a7ef9f51dd90764071557d7420ab95b" title="Computes spacetime normal vector from lapse and shift. ">gr::spacetime_normal_vector()</a></code></li>
<li><code>GeneralizedHarmonic::time_deriv_of_lapse()</code></li>
<li><code>GeneralizedHarmonic::time_deriv_of_shift()</code></li>
<li><code>null_vector_l_and_derivatives()</code></li>
<li><code>cartesian_to_spherical_coordinates_and_jacobians()</code></li>
<li><code>null_metric_and_derivative()</code></li>
<li><code>dlambda_null_metric_and_inverse()</code></li>
<li><code>bondi_r()</code></li>
<li><code>d_bondi_r()</code></li>
<li><code>dyads()</code></li>
<li><code>beta_worldtube_data()</code></li>
<li><code>bondi_u_worldtube_data()</code></li>
<li><code>bondi_w_worldtube_data()</code></li>
<li><code>bondi_j_worldtube_data()</code></li>
<li><code>dr_bondi_j()</code></li>
<li><code>d2lambda_bondi_r()</code></li>
<li><code>bondi_q_worldtube_data()</code></li>
<li><code>bondi_h_worldtube_data()</code></li>
<li><code>du_j_worldtube_data()</code> </li>
</ul>

</div>
</div>
<a id="a5bd886d931b6038954d3f405cdc391b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd886d931b6038954d3f405cdc391b1">&#9670;&nbsp;</a></span>create_bondi_boundary_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataBoxTagList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::create_bondi_boundary_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classdb_1_1DataBox.html">db::DataBox</a>&lt; DataBoxTagList &gt; *&gt;&#160;</td>
          <td class="paramname"><em>bondi_boundary_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_spatial_metric_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>extraction_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process the worldtube data from modal metric components and derivatives to desired Bondi quantities, placing the result in the passed <a class="el" href="group__DataBoxGroup.html">DataBox</a>. </p>
<h3>Details</h3>
<p>The mathematics are a bit complicated for all of the coordinate transformations that are necessary to obtain the Bondi gauge quantities. For full mathematical details, see the documentation for functions in <code><a class="el" href="BoundaryData_8hpp_source.html">BoundaryData.hpp</a></code> and <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a> <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[9]</a>.</p>
<p>This function takes as input the full set of ADM metric data and its radial and time derivatives on a two-dimensional surface of constant \(r\) and \(t\) in numerical coordinates. This data must be provided as spherical harmonic coefficients in the libsharp format. This data is provided in nine <code>Tensor</code>s.</p>
<p>Sufficient tags to provide full worldtube boundary data at a particular time are set in <code>bondi_boundary_data</code>. In particular, the set of tags in <code><a class="el" href="namespaceCce_1_1Tags.html#a7527c94f3bb08dd4124926b9ff41ebac" title="The collection of tags mutated by create_bondi_boundary_data ">Tags::characteristic_worldtube_boundary_tags</a></code> in the provided <a class="el" href="group__DataBoxGroup.html">DataBox</a> are assigned to the worldtube boundary values associated with the input metric components.</p>
<p>The majority of the mathematical transformations are implemented as a set of individual cascaded functions below. The details of the manipulations that are performed to the input data may be found in the individual functions themselves, which are called in the following order:</p><ul>
<li><code>trigonometric_functions_on_swsh_collocation()</code></li>
<li><code>cartesian_to_spherical_coordinates_and_jacobians()</code></li>
<li><code>cartesian_spatial_metric_and_derivatives_from_modes()</code></li>
<li><code>cartesian_shift_and_derivatives_from_modes()</code></li>
<li><code>cartesian_lapse_and_derivatives_from_modes()</code></li>
<li><code>GeneralizedHarmonic::phi()</code></li>
<li><code>gr::time_derivative_of_spacetime_metric</code></li>
<li><code>gr::spacetime_metric</code></li>
<li><code>generalized_harmonic_quantities()</code></li>
<li><code>worldtube_normal_and_derivatives()</code></li>
<li><code>null_vector_l_and_derivatives()</code></li>
<li><code>null_metric_and_derivative()</code></li>
<li><code>dlambda_null_metric_and_inverse()</code></li>
<li><code>bondi_r()</code></li>
<li><code>d_bondi_r()</code></li>
<li><code>dyads()</code></li>
<li><code>beta_worldtube_data()</code></li>
<li><code>bondi_u_worldtube_data()</code></li>
<li><code>bondi_w_worldtube_data()</code></li>
<li><code>bondi_j_worldtube_data()</code></li>
<li><code>dr_bondi_j()</code></li>
<li><code>d2lambda_bondi_r()</code></li>
<li><code>bondi_q_worldtube_data()</code></li>
<li><code>bondi_h_worldtube_data()</code></li>
<li><code>du_j_worldtube_data()</code> </li>
</ul>

</div>
</div>
<a id="ab19097e1f2633885d31d4f16bd305b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19097e1f2633885d31d4f16bd305b1c">&#9670;&nbsp;</a></span>create_bondi_boundary_data_from_unnormalized_spec_modes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataBoxTagList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::create_bondi_boundary_data_from_unnormalized_spec_modes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classdb_1_1DataBox.html">db::DataBox</a>&lt; DataBoxTagList &gt; *&gt;&#160;</td>
          <td class="paramname"><em>bondi_boundary_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_spatial_metric_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>extraction_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process the worldtube data from modal metric components and derivatives with incorrectly normalized radial derivatives from an old version of SpEC to desired Bondi quantities, placing the result in the passed <a class="el" href="group__DataBoxGroup.html">DataBox</a>. </p>
<h3>Details</h3>
<p>The mathematics are a bit complicated for all of the coordinate transformations that are necessary to obtain the Bondi gauge quantities. For full mathematical details, see the documentation for functions in <code><a class="el" href="BoundaryData_8hpp_source.html">BoundaryData.hpp</a></code> and <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a> <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[9]</a>.</p>
<p>This function takes as input the full set of ADM metric data and its radial and time derivatives on a two-dimensional surface of constant \(r\) and \(t\) in numerical coordinates. This data must be provided as spherical harmonic coefficients in the libsharp format. This data is provided in nine <code>Tensor</code>s.</p>
<p>Sufficient tags to provide full worldtube boundary data at a particular time are set in <code>bondi_boundary_data</code>. In particular, the set of tags in <code><a class="el" href="namespaceCce_1_1Tags.html#a7527c94f3bb08dd4124926b9ff41ebac" title="The collection of tags mutated by create_bondi_boundary_data ">Tags::characteristic_worldtube_boundary_tags</a></code> in the provided <a class="el" href="group__DataBoxGroup.html">DataBox</a> are assigned to the worldtube boundary values associated with the input metric components.</p>
<p>The majority of the mathematical transformations are implemented as a set of individual cascaded functions below. The details of the manipulations that are performed to the input data may be found in the individual functions themselves, which are called in the following order:</p><ul>
<li><code>trigonometric_functions_on_swsh_collocation()</code></li>
<li><code>cartesian_to_spherical_coordinates_and_jacobians()</code></li>
<li><code>cartesian_spatial_metric_and_derivatives_from_unnormalized_spec_modes()</code></li>
<li><code>cartesian_shift_and_derivatives_from_unnormalized_spec_modes()</code></li>
<li><code>cartesian_lapse_and_derivatives_from_unnormalized_spec_modes()</code></li>
<li><code>GeneralizedHarmonic::phi()</code></li>
<li><code>gr::time_derivative_of_spacetime_metric</code></li>
<li><code>gr::spacetime_metric</code></li>
<li><code>generalized_harmonic_quantities()</code></li>
<li><code>worldtube_normal_and_derivatives()</code></li>
<li><code>null_vector_l_and_derivatives()</code></li>
<li><code>null_metric_and_derivative()</code></li>
<li><code>dlambda_null_metric_and_inverse()</code></li>
<li><code>bondi_r()</code></li>
<li><code>d_bondi_r()</code></li>
<li><code>dyads()</code></li>
<li><code>beta_worldtube_data()</code></li>
<li><code>bondi_u_worldtube_data()</code></li>
<li><code>bondi_w_worldtube_data()</code></li>
<li><code>bondi_j_worldtube_data()</code></li>
<li><code>dr_bondi_j()</code></li>
<li><code>d2lambda_bondi_r()</code></li>
<li><code>bondi_q_worldtube_data()</code></li>
<li><code>bondi_h_worldtube_data()</code></li>
<li><code>du_j_worldtube_data()</code> </li>
</ul>

</div>
</div>
<a id="a9ac07448b0246c2878e13b941fd3160b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac07448b0246c2878e13b941fd3160b">&#9670;&nbsp;</a></span>d2lambda_bondi_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::d2lambda_bondi_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>d2lambda_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the second derivative of the Bondi radius with respect to the intermediate null coordinate radius \(\partial_\lambda^2 r\). </p>
<h3>Details</h3>
<p>To determine this second derivative quantity without resorting to depending on second-derivative metric inputs, we need to take advantage of one of the Einstein field equations. Combining equations (53) and (52) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>, we have:</p>
<p class="formulaDsp">
\[ \partial_\lambda^2 r = \frac{-r}{4} \left( \partial_\lambda J \partial_\lambda \bar J - (\partial_\lambda K)^2\right) \]
</p>
<p>,</p>
<p>where the first derivative of \(K\) can be obtained from \(K = \sqrt{1 + J \bar J}\) and the first derivative of \(J\) can be obtained from (47) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a> </p>

</div>
</div>
<a id="ac4badb01ac37f2d368a259ef85fb823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4badb01ac37f2d368a259ef85fb823e">&#9670;&nbsp;</a></span>d_bondi_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::d_bondi_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dlambda_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>du_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the full 4-dimensional partial of the Bondi radius with respect to the intermediate null coordinates. </p>
<h3>Details</h3>
<p>The expression evaluated is obtained from differentiating the determinant equation for <code>bondi_r</code>, from (35) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a> :</p>
<p class="formulaDsp">
\[ \partial_\alpha r = \frac{r}{4} \left(g^{A B} \partial_\alpha g_{A B} - \frac{\partial_\alpha \det q_{A B}}{\det q_{A B}}\right) \]
</p>
<p>Note that for the angular derivatives, we just numerically differentiate using the utilities in <code><a class="el" href="group__SpectralGroup.html#gaf2ce39b6bffcf7b2bbd66ac09f7e78b3" title="Evaluate the spin-weighted derivative DerivKind on the provided SpinWeighted&lt;ComplexDataVector, Spin&gt; collocation data, returning by value. ">Spectral::Swsh::angular_derivative()</a></code>. For the time and radial derivatives, the second term in the above equation vanishes. </p>

</div>
</div>
<a id="abb617b56d6ee954cd3e391c6cf5d20c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb617b56d6ee954cd3e391c6cf5d20c4">&#9670;&nbsp;</a></span>dlambda_null_metric_and_inverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::dlambda_null_metric_and_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>dlambda_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>dlambda_inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AngulariCartesianA &amp;&#160;</td>
          <td class="paramname"><em>angular_d_null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SphericaliCartesianJ &amp;&#160;</td>
          <td class="paramname"><em>cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>du_null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the partial derivative of the spacetime metric and inverse spacetime metric in the intermediate null radial coordinates with respect to the null generator \(l^\mu\). </p>
<h3>Details</h3>
<p>For full expressions of the \(l^\mu \partial_\mu g_{a b}\) and \(l^\mu \partial_\mu g^{a b}\) computed in this function, see equation (31) and (32) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>. Refer to <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[9]</a> for more exposition about the overall construction of the coordinate transformations used for the intermediate null coordinates. </p>

</div>
</div>
<a id="a260cf3ab8aea0f27c64269e8b5ec58c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260cf3ab8aea0f27c64269e8b5ec58c0">&#9670;&nbsp;</a></span>dr_bondi_j()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::dr_bondi_j </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>dr_bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>denominator_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dlambda_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dyad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the radial derivative of the angular metric spin-weighted scalar \(\partial_r J\) in the CCE Bondi-like metric. </p>
<h3>Details</h3>
<p>The radial derivative of the angular spin-weighted scalar \(J\) can be computed from the null metric components by (c.f. equation (47) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>):</p>
<p class="formulaDsp">
\[ \partial_r J = \frac{\partial_\lambda J}{\partial_\lambda r} = \frac{q^A q^B \partial_\lambda g_{A B} / (2 r^2) - 2 \partial_\lambda r J / r}{\partial_\lambda r} \]
</p>
 
</div>
</div>
<a id="a7c953959000b0a4e3dc411cfab510bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c953959000b0a4e3dc411cfab510bb6">&#9670;&nbsp;</a></span>du_j_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::du_j_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; *&gt;&#160;</td>
          <td class="paramname"><em>du_bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>du_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dlambda_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dyad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Bondi metric contribution \((\partial_u J)_r\) (the retarded time derivative at fixed coordinate $r$) on the worldtube boundary. </p>
<h3>Details</h3>
<p>The numerical time derivative (along the surface of constant r, not along the worldtube) is computed by (see equation (50) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>)</p>
<p class="formulaDsp">
\[ \partial_u J = \frac{1}{2 r^2} q^A q^B \left(\partial_u g_{A B} - \frac{ \partial_u r}{ \partial_\lambda r} \partial_\lambda g_{A B}\right) \]
</p>
<dl class="section note"><dt>Note</dt><dd>There is the regrettable notation difference with the primary reference for these formulas <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a> in that we denote with \(H\) the time derivative at constant numerical radius, where <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a> uses \(H\) to denote the time derivative at constant Bondi radius. </dd></dl>

</div>
</div>
<a id="aef6b36590b1996c6af1da396719c0a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6b36590b1996c6af1da396719c0a1d">&#9670;&nbsp;</a></span>dyads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::dyads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>down_dyad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>up_dyad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex angular dyads used to define the spin-weighted scalars in the CCE system. </p>
<h3>Details</h3>
<p>We use the typically chosen angular dyads in CCE <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a> <a class="el" href="citelist.html#CITEREF_Bishop1997ik">[8]</a> :</p>
<p class="formulaDsp">
\begin{align*} q_A &amp;= \{-1, -i \sin(\theta)\}\\ q^A &amp;= \left\{-1, -i \frac{1}{\sin \theta}\right\} \end{align*}
</p>
<p>However, to maintain regularity and for compatibility with the more regular Jacobians from <code>Cce::cartesian_to_spherical_coordinates_and_jacobians()</code>, in the code we omit the factors of \(\sin \theta\) from the above equations. </p>

</div>
</div>
<a id="a246fe522bad41a8830e114c7d5e136e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246fe522bad41a8830e114c7d5e136e3">&#9670;&nbsp;</a></span>logical_partial_directional_derivative_of_complex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::logical_partial_directional_derivative_of_complex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> *&gt;&#160;</td>
          <td class="paramname"><em>d_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension_to_differentiate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the partial derivative along a particular direction determined by the <code>dimension_to_differentiate</code>. The input <code>u</code> is differentiated with the spectral matrix and the solution is placed in <code>d_u</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This is placed in <a class="el" href="namespaceCce.html" title="Contains functionality for Cauchy Characteristic Extraction. ">Cce</a> Utilities for its currently narrow use-case. If more general uses desire a single partial derivative of complex values, this should be moved to <code>NumericalAlgorithms</code>. This utility currently assumes the spatial dimensionality is 3, which would also need to be generalized, likely by creating a wrapping struct with partial template specializations. </dd></dl>

</div>
</div>
<a id="a0ea7655c4828aea4ec5a29941d709860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea7655c4828aea4ec5a29941d709860">&#9670;&nbsp;</a></span>mutate_all_pre_swsh_derivatives_for_tag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BondiValueTag , typename DataBoxType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::mutate_all_pre_swsh_derivatives_for_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBoxType *&gt;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the set of inputs to the CCE integrand for <code>BondiValueTag</code> that do not involve spin-weighted angular differentiation. </p>
<h3>Details</h3>
<p>This function is to be called on the <code>DataBox</code> holding the relevant CCE data on each hypersurface integration step, prior to evaluating the spin-weighted derivatives needed for the same CCE integrand. Provided a <code>DataBox</code> with the appropriate tags (including <code>all_pre_swsh_derivative_tags</code>, <code>all_swsh_derivative_tags</code> and <code><a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1LMax.html" title="Tag for the maximum spin-weighted spherical harmonic l; sets angular resolution. ">Spectral::Swsh::Tags::LMax</a></code>), this function will apply all of the necessary mutations to update <code>all_pre_swsh_derivatives_for_tag&lt;BondiValueTag&gt;</code> to their correct values for the current values for the remaining (input) tags. </p>

</div>
</div>
<a id="ad9aaac2c0f9818a9f6c9b1f311a373c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9aaac2c0f9818a9f6c9b1f311a373c5">&#9670;&nbsp;</a></span>mutate_all_precompute_cce_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class BoundaryPrefix, typename DataBoxType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::mutate_all_precompute_cce_dependencies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBoxType *&gt;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience routine for computing all of the CCE inputs to integrand computation that do not depend on intermediate integrand results. It should be executed before moving through the hierarchy of integrands. </p>
<h3>Details</h3>
<p>Provided a <a class="el" href="group__DataBoxGroup.html">DataBox</a> with the appropriate tags (including <code><a class="el" href="namespaceCce.html#aa00307a414eb1f569706cb7d7449fa4d" title="A typelist for the set of BoundaryValue tags needed as an input to any of the template specialization...">Cce::pre_computation_boundary_tags</a></code>, <code><a class="el" href="namespaceCce.html#a7a4a1a7fe54a9f77fbf034fb95f46474" title="A typelist for the set of tags computed by the set of template specializations of PrecomputeCceDepede...">Cce::pre_computation_tags</a></code>, <code><a class="el" href="structCce_1_1Tags_1_1BondiJ.html" title="Bondi parameter . ">Cce::Tags::BondiJ</a></code> and <code><a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1LMax.html" title="Tag for the maximum spin-weighted spherical harmonic l; sets angular resolution. ">Spectral::Swsh::Tags::LMax</a></code>), this function will apply all of the necessary mutations to update the <code><a class="el" href="namespaceCce.html#a7a4a1a7fe54a9f77fbf034fb95f46474" title="A typelist for the set of tags computed by the set of template specializations of PrecomputeCceDepede...">Cce::pre_computation_tags</a></code> to their correct values for the current values for the remaining (input) tags.</p>
<p>The <code>BoundaryPrefix</code> template template parameter is to be passed a prefix tag associated with the boundary value prefix used in the computation (e.g. <code><a class="el" href="structCce_1_1Tags_1_1BoundaryValue.html" title="A prefix tag representing the boundary data for a quantity on the extraction surface. ">Cce::Tags::BoundaryValue</a></code>), and allows easy switching between the regularity-preserving version and standard CCE. </p>

</div>
</div>
<a id="a710c185e2efce13bd57e2414145c2172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710c185e2efce13bd57e2414145c2172">&#9670;&nbsp;</a></span>mutate_all_swsh_derivatives_for_tag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BondiValueTag , typename DataBoxTagList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::mutate_all_swsh_derivatives_for_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classdb_1_1DataBox.html">db::DataBox</a>&lt; DataBoxTagList &gt; *&gt;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This routine evaluates the set of inputs to the CCE integrand for <code>BondiValueTag</code> which are spin-weighted angular derivatives. </p>
<h3>Details</h3>
<p>This function is called on the <a class="el" href="group__DataBoxGroup.html">DataBox</a> holding the relevant CCE data during each hypersurface integration step, after evaluating <code><a class="el" href="namespaceCce.html#a0ea7655c4828aea4ec5a29941d709860" title="Evaluates the set of inputs to the CCE integrand for BondiValueTag that do not involve spin-weighted ...">mutate_all_pre_swsh_derivatives_for_tag()</a></code> with template argument <code>BondiValueTag</code> and before evaluating <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations...">ComputeBondiIntegrand</a>&lt;BondiValueTag&gt;</code>. Provided a <a class="el" href="group__DataBoxGroup.html">DataBox</a> with the appropriate tags (including <code><a class="el" href="namespaceCce.html#a7dd34947472e61d70007727517310500" title="A typelist for the full set of tags needed as direct or indirect input to any ComputeBondiIntegrand t...">Cce::all_pre_swsh_derivative_tags</a></code>, <code><a class="el" href="namespaceCce.html#ad3f639bb3b07cc123bdf53c26dbf0fff" title="A typelist for the set of tags computed by spin-weighted differentiation using utilities from the Sws...">Cce::all_swsh_derivative_tags</a></code>, <code><a class="el" href="namespaceCce.html#a9cbd52ad55ee87beb6abf5857c2db60a" title="A typelist for the full set of coefficient buffers needed to process all of the tags in all_swsh_deri...">Cce::all_transform_buffer_tags</a></code>, <code><a class="el" href="namespaceCce.html#a7a4a1a7fe54a9f77fbf034fb95f46474" title="A typelist for the set of tags computed by the set of template specializations of PrecomputeCceDepede...">Cce::pre_computation_tags</a></code>, and <code><a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1LMax.html" title="Tag for the maximum spin-weighted spherical harmonic l; sets angular resolution. ">Spectral::Swsh::Tags::LMax</a></code>), this function will apply all of the necessary mutations to update <code><a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html" title="A typelist for the set of tags computed by single spin-weighted differentiation using utilities from ...">Cce::single_swsh_derivative_tags_to_compute_for</a>&lt;BondiValueTag&gt;</code> and <code><a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html" title="A typelist for the set of tags computed by multiple spin-weighted differentiation using utilities fro...">Cce::second_swsh_derivative_tags_to_compute_for</a>&lt;BondiValueTag&gt;</code> to their correct values for the current values of the remaining (input) tags. </p>

</div>
</div>
<a id="a93909e253772bbdfd7a226b3bd6ea07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93909e253772bbdfd7a226b3bd6ea07a">&#9670;&nbsp;</a></span>null_metric_and_derivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::null_metric_and_derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>du_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SphericaliCartesianJ &amp;&#160;</td>
          <td class="paramname"><em>cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the spacetime metric and its first derivative in the intermediate radial null coordinates. </p>
<h3>Details</h3>
<p>These components are obtained by the steps in Section II-A of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>, which is based on the computation from Section 4.3 of <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[9]</a>. The most direct comparison is to be made with equation (31) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>, which gives the null metric components explicitly. The time derivative is then (using notation from equation (31) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>):</p>
<p class="formulaDsp">
\begin{align} \partial_{\bar u} g_{\bar u \bar \lambda} = \partial_{\bar u} g_{\bar \lambda \bar \lambda} = \partial_{\bar u} g_{\bar \lambda \bar A} &amp;= 0 \\ \partial_{\bar u} g_{\bar u \bar u} &amp;= \partial_{\breve t} g_{\breve t \breve t} \\ \partial_{\bar u} g_{\bar u \bar A} &amp;= \frac{\partial \breve x^{\breve i}}{\partial \bar x^{\bar A}}\\ g_{\breve i \breve t} \partial_{\bar u} g_{\bar A \bar B} &amp;= \frac{\partial \breve x^{\breve i}}{\partial \bar x^{\bar A}} \frac{\partial \breve x^{\breve j}}{\partial \bar x^{\bar B}} g_{\breve i \breve j} \end{align}
</p>
 
</div>
</div>
<a id="a9f0fbfceb7e1252112260c1d02a09961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0fbfceb7e1252112260c1d02a09961">&#9670;&nbsp;</a></span>null_vector_l_and_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::null_vector_l_and_derivatives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>du_null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_worldtube_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>worldtube_normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the null 4-vector \(l^\mu\) on the worldtube surface that is to be used as the CCE hypersurface generator, and the first time derivative \(\partial_u l^\mu\). </p>
<h3>Details</h3>
<p>For mathematical description of our choice of the null generator, refer to equation (22) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>, and for the first time derivative see (25) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a>. Refer to <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[9]</a> for more exposition about the overall construction of the coordinate transformations used for the intermediate null coordinates. </p>

</div>
</div>
<a id="af367dfeb1f3ee40aca23c628e9809ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af367dfeb1f3ee40aca23c628e9809ac1">&#9670;&nbsp;</a></span>precomputed_cce_q_integrator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a> &amp; Cce::precomputed_cce_q_integrator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_radial_grid_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to a lazily cached integration matrix for the \(Q\) and \(W\) equations in CCE hypersurface evaluation. </p>
<h3>Details</h3>
<p>The provided matrix acts on the integrand collocation points and solves the equation,</p>
<p class="formulaDsp">
\[ (1 - y) \partial_y f + 2 f = g, \]
</p>
<p>for \(f\) given integrand \(g\). </p>

</div>
</div>
<a id="a8001cac388464a9afee45fe2787acb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8001cac388464a9afee45fe2787acb3a">&#9670;&nbsp;</a></span>radial_integrate_cce_pole_equations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::radial_integrate_cce_pole_equations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> *&gt;&#160;</td>
          <td class="paramname"><em>integral_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pole_of_integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>regular_integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>one_minus_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_radial_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility function for evaluating the \(Q\) and \(W\) hypersurface integrals during CCE evolution. </p>
<h3>Details</h3>
<p>Computes and returns by <code>not_null</code> pointer the solution to the equation</p>
<p class="formulaDsp">
\[ (1 - y) \partial_y f + 2 f = A + (1 - y) B, \]
</p>
<p>where \(A\) is provided as <code>pole_of_integrand</code> and \(B\) is provided as <code>regular_integrand</code>. The value <code>one_minus_y</code> is required for determining the integrand and <code>l_max</code> is required to determine the shape of the spin-weighted spherical harmonic mesh. </p>

</div>
</div>
<a id="a87b43a20534ee24795c4b343c8045c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b43a20534ee24795c4b343c8045c39">&#9670;&nbsp;</a></span>trigonometric_functions_on_swsh_collocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::trigonometric_functions_on_swsh_collocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>cos_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>cos_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>sin_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>sin_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the collocation values for \(\cos(\phi)\), \(\cos(\theta)\), \(\sin(\phi)\), and \(\sin(\theta)\), returned by <code>not_null</code> pointer in that order. </p>
<h3>Details</h3>
<p>These are needed for coordinate transformations from the input Cartesian-like coordinates. </p>

</div>
</div>
<a id="a9c376c6944c906be71dafc0a37761a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c376c6944c906be71dafc0a37761a45">&#9670;&nbsp;</a></span>worldtube_normal_and_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::worldtube_normal_and_derivatives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>worldtube_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>dt_worldtube_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the spatial unit normal vector \(s^i\) to the spherical worldtube surface and its first time derivative. </p>
<h3>Details</h3>
<p>Refer to equation (20) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a> for the expression of the spatial unit normal vector, and equation (23) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[4]</a> for the first time derivative. Refer to <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[9]</a> for more exposition about the overall construction of the coordinate transformations used for the intermediate null coordinates. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2020
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
