<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - cbfbf67b7981e589bee915450d97bc54a82020ab - Elliptic/DiscontinuousGalerkin/NumericalFluxes/FirstOrderInternalPenalty.hpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title"> SpECTRE Documentation Coverage Report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">Elliptic/DiscontinuousGalerkin/NumericalFluxes</a> - FirstOrderInternalPenalty.hpp</td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
             <td class="headerItem">Commit:</td>
             <td class="headerValue"><a target="_blank" href="https://github.com/sxs-collaboration/spectre/commit/cbfbf67b7981e589bee915450d97bc54a82020ab">cbfbf67b7981e589bee915450d97bc54a82020ab</a></td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntryLo">3.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-02-19 21:30:39</td>
            <td></td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<span class="lineNum">       1 </span><span class="lineNoCov">          0 : // Distributed under the MIT License.</span>
<span class="lineNum">       2 </span>            : // See LICENSE.txt for details.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : #pragma once
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #include &lt;cstddef&gt;
<span class="lineNum">       7 </span>            : #include &lt;pup.h&gt;
<span class="lineNum">       8 </span>            : #include &lt;string&gt;
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;DataStructures/DataBox/DataBoxTag.hpp&quot;
<span class="lineNum">      11 </span>            : #include &quot;DataStructures/DataBox/Prefixes.hpp&quot;
<span class="lineNum">      12 </span>            : #include &quot;DataStructures/Tensor/Metafunctions.hpp&quot;
<span class="lineNum">      13 </span>            : #include &quot;DataStructures/Tensor/Tensor.hpp&quot;
<span class="lineNum">      14 </span>            : #include &quot;DataStructures/Variables.hpp&quot;
<span class="lineNum">      15 </span>            : #include &quot;Domain/FaceNormal.hpp&quot;
<span class="lineNum">      16 </span>            : #include &quot;Domain/Tags.hpp&quot;
<span class="lineNum">      17 </span>            : #include &quot;NumericalAlgorithms/DiscontinuousGalerkin/NormalDotFlux.hpp&quot;
<span class="lineNum">      18 </span>            : #include &quot;NumericalAlgorithms/LinearOperators/Divergence.hpp&quot;
<span class="lineNum">      19 </span>            : #include &quot;Options/Options.hpp&quot;
<span class="lineNum">      20 </span>            : #include &quot;Utilities/Gsl.hpp&quot;
<span class="lineNum">      21 </span>            : #include &quot;Utilities/TMPL.hpp&quot;
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : /// \cond
<span class="lineNum">      24 </span>            : class DataVector;
<span class="lineNum">      25 </span>            : namespace Tags {
<span class="lineNum">      26 </span>            : template &lt;typename&gt;
<span class="lineNum">      27 </span>            : struct Normalized;
<span class="lineNum">      28 </span>            : }  // namespace Tags
<span class="lineNum">      29 </span>            : /// \endcond
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : namespace elliptic {
<span class="lineNum">      32 </span>            : namespace dg {
<span class="lineNum">      33 </span><span class="lineNoCov">          0 : namespace NumericalFluxes {</span>
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : /*!
<span class="lineNum">      36 </span>            :  * \ingroup DiscontinuousGalerkinGroup
<span class="lineNum">      37 </span>            :  * \ingroup NumericalFluxesGroup
<span class="lineNum">      38 </span>            :  * \brief The internal penalty flux for first-order elliptic equations.
<span class="lineNum">      39 </span>            :  *
<span class="lineNum">      40 </span>            :  * \details Computes the internal penalty numerical flux (see e.g.
<span class="lineNum">      41 </span>            :  * \cite HesthavenWarburton, section 7.2) dotted with the interface unit normal.
<span class="lineNum">      42 </span>            :  *
<span class="lineNum">      43 </span>            :  * We implement here a suggested generalization of the internal penalty flux
<span class="lineNum">      44 </span>            :  * for any set of elliptic PDEs up to second order in derivatives. It is
<span class="lineNum">      45 </span>            :  * designed for fluxes (i.e. principal parts of the PDEs) that may depend on the
<span class="lineNum">      46 </span>            :  * dynamic fields, but do so at most linearly. This is the case for the velocity
<span class="lineNum">      47 </span>            :  * potential equation of binary neutron stars, for example. The linearity is
<span class="lineNum">      48 </span>            :  * only necessary to impose inhomogeneous boundary conditions as contributions
<span class="lineNum">      49 </span>            :  * to the fixed source (see
<span class="lineNum">      50 </span>            :  * `elliptic::dg::Actions::ImposeInhomogeneousBoundaryConditionsOnSource`).
<span class="lineNum">      51 </span>            :  *
<span class="lineNum">      52 </span>            :  * We reduce the second-order elliptic PDEs to first-order form by introducing
<span class="lineNum">      53 </span>            :  * an _auxiliary_ variable \f$v\f$ for each _primal_ variable \f$u\f$ (i.e. for
<span class="lineNum">      54 </span>            :  * each variable whose second derivative appears in the equations). Then, the
<span class="lineNum">      55 </span>            :  * equations take the _flux-form_
<span class="lineNum">      56 </span>            :  *
<span class="lineNum">      57 </span>            :  * \f{align}
<span class="lineNum">      58 </span>            :  * -\partial_i F^i_A + S_A = f_A
<span class="lineNum">      59 </span>            :  * \f}
<span class="lineNum">      60 </span>            :  *
<span class="lineNum">      61 </span>            :  * where the fluxes \f$F^i_A(u,v)\f$ and sources \f$S_A(u,v)\f$ are indexed
<span class="lineNum">      62 </span>            :  * (with capital letters) by the variables and we have defined \f$f_A(x)\f$ as
<span class="lineNum">      63 </span>            :  * those sources that are independent of the variables. Note that the fluxes are
<span class="lineNum">      64 </span>            :  * functions of the primal and auxiliary variables; e.g. for a Poisson system
<span class="lineNum">      65 </span>            :  * \f$\{u,v_i\}\f$ on a spatial metric \f$\gamma_{ij}\f$ they are simply
<span class="lineNum">      66 </span>            :  * \f$F^i_u(v)=\sqrt{\gamma}\gamma^{ij} v_j\f$ and
<span class="lineNum">      67 </span>            :  * \f$F^i_{v_j}(u)=u\delta^i_j\f$ (see `Poisson::FirstOrderSystem`) or for an
<span class="lineNum">      68 </span>            :  * Elasticity system \f$\{\xi^i,S_{ij}\}\f$ with Young's tensor
<span class="lineNum">      69 </span>            :  * \f$Y^{ijkl}\f$ they are \f$F^i_{\xi^j}(S)=Y^{ijkl}S_{kl}\f$ and
<span class="lineNum">      70 </span>            :  * \f$F^i_{S_{jk}}(\xi)=\delta^i_{(j}\xi_{k)}\f$. Since each primal flux is
<span class="lineNum">      71 </span>            :  * commonly only a function of the corresponding auxiliary variable and
<span class="lineNum">      72 </span>            :  * vice-versa, we omit the other function arguments here to lighten the
<span class="lineNum">      73 </span>            :  * notational load.
<span class="lineNum">      74 </span>            :  *
<span class="lineNum">      75 </span>            :  * We now choose the internal penalty numerical fluxes \f$(n_i F^i_A)^*\f$ as
<span class="lineNum">      76 </span>            :  * follows for each primal variable \f$u\f$ and their corresponding auxiliary
<span class="lineNum">      77 </span>            :  * variable \f$v\f$:
<span class="lineNum">      78 </span>            :  *
<span class="lineNum">      79 </span>            :  * \f{align}
<span class="lineNum">      80 </span>            :  * (n_i F^i_u)^* &amp;= \frac{1}{2} n_i \left( F^i_u(\partial_j
<span class="lineNum">      81 </span>            :  * F^j_v(u^\mathrm{int})) + F^i_u(\partial_j F^j_v(u^\mathrm{ext}))
<span class="lineNum">      82 </span>            :  * \right) - \sigma n_i \left(F^i_u(n_j F^j_v(u^\mathrm{int})) - F^i_u(
<span class="lineNum">      83 </span>            :  * n_j F^j_v(u^\mathrm{ext}))\right) \\
<span class="lineNum">      84 </span>            :  * (n_i F^i_v)^* &amp;= \frac{1}{2} n_i \left(F^i_v(u^\mathrm{int}) +
<span class="lineNum">      85 </span>            :  * F^i_v(u^\mathrm{ext})\right)
<span class="lineNum">      86 </span>            :  * \f}
<span class="lineNum">      87 </span>            :  *
<span class="lineNum">      88 </span>            :  * Note that we have assumed \f$n^\mathrm{ext}_i=-n_i\f$ here, i.e. face normals
<span class="lineNum">      89 </span>            :  * don't depend on the dynamic variables (which may be discontinuous on element
<span class="lineNum">      90 </span>            :  * faces). This is the case for the problems we are expecting to solve, because
<span class="lineNum">      91 </span>            :  * those will be on fixed background metrics (e.g. a conformal metric for the
<span class="lineNum">      92 </span>            :  * XCTS system).
<span class="lineNum">      93 </span>            :  *
<span class="lineNum">      94 </span>            :  * Also note that the numerical fluxes intentionally don't depend on the
<span class="lineNum">      95 </span>            :  * auxiliary field values \f$v\f$. This property allows us to use the numerical
<span class="lineNum">      96 </span>            :  * fluxes also for the second-order (or _primal_) DG formulation, where we
<span class="lineNum">      97 </span>            :  * remove the need for an auxiliary variable. For the first-order system we
<span class="lineNum">      98 </span>            :  * could replace the divergence in \f$(n_i F^i_u)^*\f$ with \f$v\f$, which would
<span class="lineNum">      99 </span>            :  * result in a generalized &quot;stabilized central flux&quot; that is slightly less
<span class="lineNum">     100 </span>            :  * sparse than the internal penalty flux (see e.g. \cite HesthavenWarburton,
<span class="lineNum">     101 </span>            :  * section 7.2). We could also choose to ignore the fluxes in the penalty term,
<span class="lineNum">     102 </span>            :  * but preliminary tests suggest that this may hurt convergence.
<span class="lineNum">     103 </span>            :  *
<span class="lineNum">     104 </span>            :  * For a Poisson system (see above) this numeric flux reduces to the standard
<span class="lineNum">     105 </span>            :  * internal penalty flux (see e.g. \cite HesthavenWarburton, section 7.2, or
<span class="lineNum">     106 </span>            :  * \cite Arnold2002)
<span class="lineNum">     107 </span>            :  *
<span class="lineNum">     108 </span>            :  * \f{align}
<span class="lineNum">     109 </span>            :  * (n_i F^i_u)^* &amp;= n_i v_i^* = \frac{1}{2} n_i \left(\partial_i u^\mathrm{int}
<span class="lineNum">     110 </span>            :  * + \partial_i u^\mathrm{ext}\right) - \sigma \left(u^\mathrm{int} -
<span class="lineNum">     111 </span>            :  * u^\mathrm{ext}\right) \\
<span class="lineNum">     112 </span>            :  * (n_i F^i_{v_j})^* &amp;= n_j u^* = \frac{1}{2} n_j \left(u^\mathrm{int} +
<span class="lineNum">     113 </span>            :  * u^\mathrm{ext}\right)
<span class="lineNum">     114 </span>            :  * \f}
<span class="lineNum">     115 </span>            :  *
<span class="lineNum">     116 </span>            :  * where a sum over repeated indices is assumed, since the equation is
<span class="lineNum">     117 </span>            :  * formulated on a Euclidean geometry.
<span class="lineNum">     118 </span>            :  *
<span class="lineNum">     119 </span>            :  * This generalization of the internal penalty flux is based on unpublished work
<span class="lineNum">     120 </span>            :  * by Nils L. Fischer (nils.fischer@aei.mpg.de).
<span class="lineNum">     121 </span>            :  *
<span class="lineNum">     122 </span>            :  * The penalty factor \f$\sigma\f$ is responsible for removing zero eigenmodes
<span class="lineNum">     123 </span>            :  * and impacts the conditioning of the linear operator to be solved. It can be
<span class="lineNum">     124 </span>            :  * chosen as \f$\sigma=C\frac{N_\mathrm{points}^2}{h}\f$ where
<span class="lineNum">     125 </span>            :  * \f$N_\mathrm{points}\f$ is the number of collocation points (i.e. the
<span class="lineNum">     126 </span>            :  * polynomial degree plus 1), \f$h\f$ is a measure of the element size in
<span class="lineNum">     127 </span>            :  * inertial coordinates (both measured perpendicular to the interface under
<span class="lineNum">     128 </span>            :  * consideration) and \f$C\geq 1\f$ is a free parameter (see e.g.
<span class="lineNum">     129 </span>            :  * \cite HesthavenWarburton, section 7.2).
<span class="lineNum">     130 </span>            :  */
<span class="lineNum">     131 </span>            : template &lt;size_t Dim, typename FluxesComputerTag, typename FieldTagsList,
<span class="lineNum">     132 </span>            :           typename AuxiliaryFieldTagsList,
<span class="lineNum">     133 </span>            :           typename FluxesComputer = db::item_type&lt;FluxesComputerTag&gt;,
<span class="lineNum">     134 </span>            :           typename FluxesArgs = typename FluxesComputer::argument_tags&gt;
<span class="lineNum">     135 </span><span class="lineCov">          1 : struct FirstOrderInternalPenalty;</span>
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : template &lt;size_t Dim, typename FluxesComputerTag, typename... FieldTags,
<span class="lineNum">     138 </span>            :           typename... AuxiliaryFieldTags, typename FluxesComputer,
<span class="lineNum">     139 </span>            :           typename... FluxesArgs&gt;
<span class="lineNum">     140 </span>            : struct FirstOrderInternalPenalty&lt;Dim, FluxesComputerTag,
<span class="lineNum">     141 </span>            :                                  tmpl::list&lt;FieldTags...&gt;,
<span class="lineNum">     142 </span>            :                                  tmpl::list&lt;AuxiliaryFieldTags...&gt;,
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :                                  FluxesComputer, tmpl::list&lt;FluxesArgs...&gt;&gt; {</span>
<span class="lineNum">     144 </span>            :  private:
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   using fluxes_computer_tag = FluxesComputerTag;</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :   template &lt;typename Tag&gt;
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   struct NormalDotDivFlux : db::PrefixTag, db::SimpleTag {</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     using tag = Tag;</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     using type = TensorMetafunctions::remove_first_index&lt;db::item_type&lt;Tag&gt;&gt;;</span>
<span class="lineNum">     151 </span>            :   };
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            :   template &lt;typename Tag&gt;
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   struct NormalDotNormalDotFlux : db::PrefixTag, db::SimpleTag {</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     using tag = Tag;</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     using type = TensorMetafunctions::remove_first_index&lt;db::item_type&lt;Tag&gt;&gt;;</span>
<span class="lineNum">     157 </span>            :   };
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            :  public:
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   struct PenaltyParameter {</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     using type = double;</span>
<span class="lineNum">     162 </span>            :     // Currently this is used as the full prefactor `sigma` to the penalty term.
<span class="lineNum">     163 </span>            :     // This means it needs to be chosen large enough so that the scheme is
<span class="lineNum">     164 </span>            :     // stable everywhere. A good estimate is the the largest
<span class="lineNum">     165 </span>            :     // `sigma &gt; N_points^2 / h` (see class documentation) over all elements in
<span class="lineNum">     166 </span>            :     // the domain. Choosing `sigma` the same everywhere means it is an
<span class="lineNum">     167 </span>            :     // overestimate on non-uniform meshes where elements are large or polynomial
<span class="lineNum">     168 </span>            :     // degrees are small, but this only affects the conditioning of the scheme,
<span class="lineNum">     169 </span>            :     // i.e. it will converge slower but to the same solution. When it becomes
<span class="lineNum">     170 </span>            :     // possible to communicate non-tensors (the element size and the number of
<span class="lineNum">     171 </span>            :     // collocation points on either side of the mortar), this option will be
<span class="lineNum">     172 </span>            :     // changed to be just the free parameter `C` multiplying `N_points^2 / h`.
<span class="lineNum">     173 </span>            :     // This will improve conditioning on non-uniform meshes. Currently, the
<span class="lineNum">     174 </span>            :     // `packaged_data` is a `Variables` which can only hold tensors.
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :     static constexpr OptionString help = {</span>
<span class="lineNum">     176 </span>            :         &quot;The prefactor to the penalty term of the flux.&quot;};
<span class="lineNum">     177 </span>            :   };
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   using options = tmpl::list&lt;PenaltyParameter&gt;;</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :   static constexpr OptionString help = {</span>
<span class="lineNum">     180 </span>            :       &quot;The internal penalty flux for elliptic systems.&quot;};
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   static std::string name() noexcept { return &quot;InternalPenalty&quot;; }</span>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   FirstOrderInternalPenalty() = default;</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   explicit FirstOrderInternalPenalty(const double penalty_parameter) noexcept</span>
<span class="lineNum">     185 </span>            :       : penalty_parameter_(penalty_parameter) {}
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            :   // clang-tidy: non-const reference
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   void pup(PUP::er&amp; p) noexcept { p | penalty_parameter_; }  // NOLINT</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :   // These tags are sliced to the interface of the element and passed to
<span class="lineNum">     191 </span>            :   // `package_data` to provide the data needed to compute the numerical fluxes.
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   using argument_tags =</span>
<span class="lineNum">     193 </span>            :       tmpl::list&lt;::Tags::NormalDotFlux&lt;AuxiliaryFieldTags&gt;...,
<span class="lineNum">     194 </span>            :                  ::Tags::div&lt;::Tags::Flux&lt;AuxiliaryFieldTags, tmpl::size_t&lt;Dim&gt;,
<span class="lineNum">     195 </span>            :                                           Frame::Inertial&gt;&gt;...,
<span class="lineNum">     196 </span>            :                  fluxes_computer_tag, FluxesArgs...,
<span class="lineNum">     197 </span>            :                  ::Tags::Normalized&lt;::Tags::UnnormalizedFaceNormal&lt;Dim&gt;&gt;&gt;;
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   using volume_tags = tmpl::list&lt;fluxes_computer_tag&gt;;</span>
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :   // This is the data needed to compute the numerical flux.
<span class="lineNum">     201 </span>            :   // `SendBoundaryFluxes` calls `package_data` to store these tags in a
<span class="lineNum">     202 </span>            :   // Variables. Local and remote values of this data are then combined in the
<span class="lineNum">     203 </span>            :   // `()` operator.
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   using package_tags =</span>
<span class="lineNum">     205 </span>            :       tmpl::list&lt;::Tags::NormalDotFlux&lt;AuxiliaryFieldTags&gt;...,
<span class="lineNum">     206 </span>            :                  NormalDotDivFlux&lt;AuxiliaryFieldTags&gt;...,
<span class="lineNum">     207 </span>            :                  NormalDotNormalDotFlux&lt;AuxiliaryFieldTags&gt;...&gt;;
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :   // Following the packaged_data pointer, this function expects as arguments the
<span class="lineNum">     210 </span>            :   // types in `argument_tags`.
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :   void package_data(</span>
<span class="lineNum">     212 </span>            :       const gsl::not_null&lt;Variables&lt;package_tags&gt;*&gt; packaged_data,
<span class="lineNum">     213 </span>            :       const db::item_type&lt;::Tags::NormalDotFlux&lt;
<span class="lineNum">     214 </span>            :           AuxiliaryFieldTags&gt;&gt;&amp;... normal_dot_auxiliary_field_fluxes,
<span class="lineNum">     215 </span>            :       const db::item_type&lt;::Tags::div&lt;
<span class="lineNum">     216 </span>            :           ::Tags::Flux&lt;AuxiliaryFieldTags, tmpl::size_t&lt;Dim&gt;,
<span class="lineNum">     217 </span>            :                        Frame::Inertial&gt;&gt;&gt;&amp;... div_auxiliary_field_fluxes,
<span class="lineNum">     218 </span>            :       const FluxesComputer&amp; fluxes_computer,
<span class="lineNum">     219 </span>            :       const db::item_type&lt;FluxesArgs&gt;&amp;... fluxes_args,
<span class="lineNum">     220 </span>            :       const tnsr::i&lt;DataVector, Dim, Frame::Inertial&gt;&amp; interface_unit_normal)
<span class="lineNum">     221 </span>            :       const noexcept {
<span class="lineNum">     222 </span>            :     auto principal_div_aux_field_fluxes = make_with_value&lt;Variables&lt;tmpl::list&lt;
<span class="lineNum">     223 </span>            :         ::Tags::Flux&lt;FieldTags, tmpl::size_t&lt;Dim&gt;, Frame::Inertial&gt;...&gt;&gt;&gt;(
<span class="lineNum">     224 </span>            :         interface_unit_normal, std::numeric_limits&lt;double&gt;::signaling_NaN());
<span class="lineNum">     225 </span>            :     auto principal_ndot_aux_field_fluxes = make_with_value&lt;Variables&lt;tmpl::list&lt;
<span class="lineNum">     226 </span>            :         ::Tags::Flux&lt;FieldTags, tmpl::size_t&lt;Dim&gt;, Frame::Inertial&gt;...&gt;&gt;&gt;(
<span class="lineNum">     227 </span>            :         interface_unit_normal, std::numeric_limits&lt;double&gt;::signaling_NaN());
<span class="lineNum">     228 </span>            :     fluxes_computer.apply(
<span class="lineNum">     229 </span>            :         make_not_null(
<span class="lineNum">     230 </span>            :             &amp;get&lt;::Tags::Flux&lt;FieldTags, tmpl::size_t&lt;Dim&gt;, Frame::Inertial&gt;&gt;(
<span class="lineNum">     231 </span>            :                 principal_div_aux_field_fluxes))...,
<span class="lineNum">     232 </span>            :         fluxes_args..., div_auxiliary_field_fluxes...);
<span class="lineNum">     233 </span>            :     fluxes_computer.apply(
<span class="lineNum">     234 </span>            :         make_not_null(
<span class="lineNum">     235 </span>            :             &amp;get&lt;::Tags::Flux&lt;FieldTags, tmpl::size_t&lt;Dim&gt;, Frame::Inertial&gt;&gt;(
<span class="lineNum">     236 </span>            :                 principal_ndot_aux_field_fluxes))...,
<span class="lineNum">     237 </span>            :         fluxes_args..., normal_dot_auxiliary_field_fluxes...);
<span class="lineNum">     238 </span>            :     const auto apply_normal_dot =
<span class="lineNum">     239 </span>            :         [
<span class="lineNum">     240 </span>            :           &amp;packaged_data, &amp;principal_div_aux_field_fluxes,
<span class="lineNum">     241 </span>            :           &amp;principal_ndot_aux_field_fluxes, &amp;interface_unit_normal
<span class="lineNum">     242 </span>            :         ](auto field_tag_v, auto auxiliary_field_tag_v,
<span class="lineNum">     243 </span>            :           const auto&amp; normal_dot_auxiliary_field_flux) noexcept {
<span class="lineNum">     244 </span>            :       using field_tag = decltype(field_tag_v);
<span class="lineNum">     245 </span>            :       using auxiliary_field_tag = decltype(auxiliary_field_tag_v);
<span class="lineNum">     246 </span>            :       // Compute n.F_v(u)
<span class="lineNum">     247 </span>            :       get&lt;::Tags::NormalDotFlux&lt;auxiliary_field_tag&gt;&gt;(*packaged_data) =
<span class="lineNum">     248 </span>            :           normal_dot_auxiliary_field_flux;
<span class="lineNum">     249 </span>            :       // Compute n.F_u(div(F_v(u))) and n.F_u(n.F_v(u))
<span class="lineNum">     250 </span>            :       normal_dot_flux(
<span class="lineNum">     251 </span>            :           make_not_null(
<span class="lineNum">     252 </span>            :               &amp;get&lt;NormalDotDivFlux&lt;auxiliary_field_tag&gt;&gt;(*packaged_data)),
<span class="lineNum">     253 </span>            :           interface_unit_normal,
<span class="lineNum">     254 </span>            :           get&lt;::Tags::Flux&lt;field_tag, tmpl::size_t&lt;Dim&gt;, Frame::Inertial&gt;&gt;(
<span class="lineNum">     255 </span>            :               principal_div_aux_field_fluxes));
<span class="lineNum">     256 </span>            :       normal_dot_flux(
<span class="lineNum">     257 </span>            :           make_not_null(&amp;get&lt;NormalDotNormalDotFlux&lt;auxiliary_field_tag&gt;&gt;(
<span class="lineNum">     258 </span>            :               *packaged_data)),
<span class="lineNum">     259 </span>            :           interface_unit_normal,
<span class="lineNum">     260 </span>            :           get&lt;::Tags::Flux&lt;field_tag, tmpl::size_t&lt;Dim&gt;, Frame::Inertial&gt;&gt;(
<span class="lineNum">     261 </span>            :               principal_ndot_aux_field_fluxes));
<span class="lineNum">     262 </span>            :     };
<span class="lineNum">     263 </span>            :     EXPAND_PACK_LEFT_TO_RIGHT(apply_normal_dot(
<span class="lineNum">     264 </span>            :         FieldTags{}, AuxiliaryFieldTags{}, normal_dot_auxiliary_field_fluxes));
<span class="lineNum">     265 </span>            :   }
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :   // This function combines local and remote data to the numerical fluxes.
<span class="lineNum">     268 </span>            :   // The numerical fluxes as not-null pointers are the first arguments. The
<span class="lineNum">     269 </span>            :   // other arguments are the packaged types for the interior side followed by
<span class="lineNum">     270 </span>            :   // the packaged types for the exterior side.
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   void operator()(</span>
<span class="lineNum">     272 </span>            :       const gsl::not_null&lt;db::item_type&lt;::Tags::NormalDotNumericalFlux&lt;
<span class="lineNum">     273 </span>            :           FieldTags&gt;&gt;*&gt;... numerical_flux_for_fields,
<span class="lineNum">     274 </span>            :       const gsl::not_null&lt;db::item_type&lt;::Tags::NormalDotNumericalFlux&lt;
<span class="lineNum">     275 </span>            :           AuxiliaryFieldTags&gt;&gt;*&gt;... numerical_flux_for_auxiliary_fields,
<span class="lineNum">     276 </span>            :       const db::item_type&lt;::Tags::NormalDotFlux&lt;
<span class="lineNum">     277 </span>            :           AuxiliaryFieldTags&gt;&gt;&amp;... normal_dot_auxiliary_flux_interiors,
<span class="lineNum">     278 </span>            :       const db::item_type&lt;NormalDotDivFlux&lt;
<span class="lineNum">     279 </span>            :           AuxiliaryFieldTags&gt;&gt;&amp;... normal_dot_div_auxiliary_flux_interiors,
<span class="lineNum">     280 </span>            :       const db::item_type&lt;NormalDotNormalDotFlux&lt;
<span class="lineNum">     281 </span>            :           AuxiliaryFieldTags&gt;&gt;&amp;... ndot_ndot_aux_flux_interiors,
<span class="lineNum">     282 </span>            :       const db::item_type&lt;::Tags::NormalDotFlux&lt;
<span class="lineNum">     283 </span>            :           AuxiliaryFieldTags&gt;&gt;&amp;... minus_normal_dot_auxiliary_flux_exteriors,
<span class="lineNum">     284 </span>            :       const db::item_type&lt;NormalDotDivFlux&lt;
<span class="lineNum">     285 </span>            :           AuxiliaryFieldTags&gt;&gt;&amp;... minus_normal_dot_div_aux_flux_exteriors,
<span class="lineNum">     286 </span>            :       const db::item_type&lt;NormalDotDivFlux&lt;
<span class="lineNum">     287 </span>            :           AuxiliaryFieldTags&gt;&gt;&amp;... ndot_ndot_aux_flux_exteriors) const
<span class="lineNum">     288 </span>            :       noexcept {
<span class="lineNum">     289 </span>            :     // Need polynomial degrees and element size to compute this dynamically
<span class="lineNum">     290 </span>            :     const double penalty = penalty_parameter_;
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :     const auto assemble_numerical_fluxes = [&amp;penalty](
<span class="lineNum">     293 </span>            :         const auto numerical_flux_for_field,
<span class="lineNum">     294 </span>            :         const auto numerical_flux_for_auxiliary_field,
<span class="lineNum">     295 </span>            :         const auto&amp; normal_dot_auxiliary_flux_interior,
<span class="lineNum">     296 </span>            :         const auto&amp; normal_dot_div_auxiliary_flux_interior,
<span class="lineNum">     297 </span>            :         const auto&amp; ndot_ndot_aux_flux_interior,
<span class="lineNum">     298 </span>            :         const auto&amp; minus_normal_dot_auxiliary_flux_exterior,
<span class="lineNum">     299 </span>            :         const auto&amp; minus_normal_dot_div_aux_flux_exterior,
<span class="lineNum">     300 </span>            :         const auto&amp; ndot_ndot_aux_flux_exterior) noexcept {
<span class="lineNum">     301 </span>            :       for (auto it = numerical_flux_for_auxiliary_field-&gt;begin();
<span class="lineNum">     302 </span>            :            it != numerical_flux_for_auxiliary_field-&gt;end(); it++) {
<span class="lineNum">     303 </span>            :         const auto index =
<span class="lineNum">     304 </span>            :             numerical_flux_for_auxiliary_field-&gt;get_tensor_index(it);
<span class="lineNum">     305 </span>            :         // We are working with the n.F_v(u) computed on either side of the
<span class="lineNum">     306 </span>            :         // interface, so (assuming the normal is independent of the dynamic
<span class="lineNum">     307 </span>            :         // variables) the data we get from the other element contains _minus_
<span class="lineNum">     308 </span>            :         // the normal from this element. So we cancel the minus sign when
<span class="lineNum">     309 </span>            :         // computing the average here.
<span class="lineNum">     310 </span>            :         *it = 0.5 * (normal_dot_auxiliary_flux_interior.get(index) -
<span class="lineNum">     311 </span>            :                      minus_normal_dot_auxiliary_flux_exterior.get(index));
<span class="lineNum">     312 </span>            :       }
<span class="lineNum">     313 </span>            :       for (auto it = numerical_flux_for_field-&gt;begin();
<span class="lineNum">     314 </span>            :            it != numerical_flux_for_field-&gt;end(); it++) {
<span class="lineNum">     315 </span>            :         const auto index = numerical_flux_for_field-&gt;get_tensor_index(it);
<span class="lineNum">     316 </span>            :         *it = 0.5 * (normal_dot_div_auxiliary_flux_interior.get(index) -
<span class="lineNum">     317 </span>            :                      minus_normal_dot_div_aux_flux_exterior.get(index)) -
<span class="lineNum">     318 </span>            :               penalty * (ndot_ndot_aux_flux_interior.get(index) -
<span class="lineNum">     319 </span>            :                          ndot_ndot_aux_flux_exterior.get(index));
<span class="lineNum">     320 </span>            :       }
<span class="lineNum">     321 </span>            :     };
<span class="lineNum">     322 </span>            :     EXPAND_PACK_LEFT_TO_RIGHT(assemble_numerical_fluxes(
<span class="lineNum">     323 </span>            :         numerical_flux_for_fields, numerical_flux_for_auxiliary_fields,
<span class="lineNum">     324 </span>            :         normal_dot_auxiliary_flux_interiors,
<span class="lineNum">     325 </span>            :         normal_dot_div_auxiliary_flux_interiors, ndot_ndot_aux_flux_interiors,
<span class="lineNum">     326 </span>            :         minus_normal_dot_auxiliary_flux_exteriors,
<span class="lineNum">     327 </span>            :         minus_normal_dot_div_aux_flux_exteriors, ndot_ndot_aux_flux_exteriors));
<span class="lineNum">     328 </span>            :   }
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :   // This function computes the boundary contributions from Dirichlet boundary
<span class="lineNum">     331 </span>            :   // conditions. This data is what remains to be added to the boundaries when
<span class="lineNum">     332 </span>            :   // homogeneous (i.e. zero) boundary conditions are assumed in the calculation
<span class="lineNum">     333 </span>            :   // of the numerical fluxes, but we wish to impose inhomogeneous (i.e. nonzero)
<span class="lineNum">     334 </span>            :   // boundary conditions. Since this contribution does not depend on the
<span class="lineNum">     335 </span>            :   // numerical field values, but only on the Dirichlet boundary data, it may be
<span class="lineNum">     336 </span>            :   // added as contribution to the source of the elliptic systems. Then, it
<span class="lineNum">     337 </span>            :   // remains to solve the homogeneous problem with the modified source.
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   void compute_dirichlet_boundary(</span>
<span class="lineNum">     339 </span>            :       const gsl::not_null&lt;db::item_type&lt;::Tags::NormalDotNumericalFlux&lt;
<span class="lineNum">     340 </span>            :           FieldTags&gt;&gt;*&gt;... numerical_flux_for_fields,
<span class="lineNum">     341 </span>            :       const gsl::not_null&lt;db::item_type&lt;::Tags::NormalDotNumericalFlux&lt;
<span class="lineNum">     342 </span>            :           AuxiliaryFieldTags&gt;&gt;*&gt;... numerical_flux_for_auxiliary_fields,
<span class="lineNum">     343 </span>            :       const db::item_type&lt;FieldTags&gt;&amp;... dirichlet_fields,
<span class="lineNum">     344 </span>            :       const FluxesComputer&amp; fluxes_computer,
<span class="lineNum">     345 </span>            :       const db::item_type&lt;FluxesArgs&gt;&amp;... fluxes_args,
<span class="lineNum">     346 </span>            :       const tnsr::i&lt;DataVector, Dim, Frame::Inertial&gt;&amp; interface_unit_normal)
<span class="lineNum">     347 </span>            :       const noexcept {
<span class="lineNum">     348 </span>            :     // Need polynomial degrees and element size to compute this dynamically
<span class="lineNum">     349 </span>            :     const double penalty = penalty_parameter_;
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            :     // Compute n.F_v(u)
<span class="lineNum">     352 </span>            :     auto dirichlet_auxiliary_field_fluxes =
<span class="lineNum">     353 </span>            :         make_with_value&lt;Variables&lt;tmpl::list&lt;::Tags::Flux&lt;
<span class="lineNum">     354 </span>            :             AuxiliaryFieldTags, tmpl::size_t&lt;Dim&gt;, Frame::Inertial&gt;...&gt;&gt;&gt;(
<span class="lineNum">     355 </span>            :             interface_unit_normal,
<span class="lineNum">     356 </span>            :             std::numeric_limits&lt;double&gt;::signaling_NaN());
<span class="lineNum">     357 </span>            :     fluxes_computer.apply(
<span class="lineNum">     358 </span>            :         make_not_null(&amp;get&lt;::Tags::Flux&lt;AuxiliaryFieldTags, tmpl::size_t&lt;Dim&gt;,
<span class="lineNum">     359 </span>            :                                         Frame::Inertial&gt;&gt;(
<span class="lineNum">     360 </span>            :             dirichlet_auxiliary_field_fluxes))...,
<span class="lineNum">     361 </span>            :         fluxes_args..., dirichlet_fields...);
<span class="lineNum">     362 </span>            :     const auto apply_normal_dot_aux =
<span class="lineNum">     363 </span>            :         [&amp;interface_unit_normal, &amp;dirichlet_auxiliary_field_fluxes ](
<span class="lineNum">     364 </span>            :             auto auxiliary_field_tag_v,
<span class="lineNum">     365 </span>            :             const auto numerical_flux_for_auxiliary_field) noexcept {
<span class="lineNum">     366 </span>            :       using auxiliary_field_tag = decltype(auxiliary_field_tag_v);
<span class="lineNum">     367 </span>            :       normal_dot_flux(
<span class="lineNum">     368 </span>            :           numerical_flux_for_auxiliary_field, interface_unit_normal,
<span class="lineNum">     369 </span>            :           get&lt;::Tags::Flux&lt;auxiliary_field_tag, tmpl::size_t&lt;Dim&gt;,
<span class="lineNum">     370 </span>            :                            Frame::Inertial&gt;&gt;(dirichlet_auxiliary_field_fluxes));
<span class="lineNum">     371 </span>            :     };
<span class="lineNum">     372 </span>            :     EXPAND_PACK_LEFT_TO_RIGHT(apply_normal_dot_aux(
<span class="lineNum">     373 </span>            :         AuxiliaryFieldTags{}, numerical_flux_for_auxiliary_fields));
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :     // Compute 2 * sigma * n.F_u(n.F_v(u))
<span class="lineNum">     376 </span>            :     auto principal_dirichlet_auxiliary_field_fluxes =
<span class="lineNum">     377 </span>            :         make_with_value&lt;Variables&lt;tmpl::list&lt;
<span class="lineNum">     378 </span>            :             ::Tags::Flux&lt;FieldTags, tmpl::size_t&lt;Dim&gt;, Frame::Inertial&gt;...&gt;&gt;&gt;(
<span class="lineNum">     379 </span>            :             interface_unit_normal,
<span class="lineNum">     380 </span>            :             std::numeric_limits&lt;double&gt;::signaling_NaN());
<span class="lineNum">     381 </span>            :     fluxes_computer.apply(
<span class="lineNum">     382 </span>            :         make_not_null(
<span class="lineNum">     383 </span>            :             &amp;get&lt;::Tags::Flux&lt;FieldTags, tmpl::size_t&lt;Dim&gt;, Frame::Inertial&gt;&gt;(
<span class="lineNum">     384 </span>            :                 principal_dirichlet_auxiliary_field_fluxes))...,
<span class="lineNum">     385 </span>            :         fluxes_args..., *numerical_flux_for_auxiliary_fields...);
<span class="lineNum">     386 </span>            :     const auto assemble_dirichlet_penalty = [
<span class="lineNum">     387 </span>            :       &amp;interface_unit_normal, &amp;penalty,
<span class="lineNum">     388 </span>            :       &amp;principal_dirichlet_auxiliary_field_fluxes
<span class="lineNum">     389 </span>            :     ](auto field_tag_v, const auto numerical_flux_for_field) noexcept {
<span class="lineNum">     390 </span>            :       using field_tag = decltype(field_tag_v);
<span class="lineNum">     391 </span>            :       normal_dot_flux(
<span class="lineNum">     392 </span>            :           numerical_flux_for_field, interface_unit_normal,
<span class="lineNum">     393 </span>            :           get&lt;::Tags::Flux&lt;field_tag, tmpl::size_t&lt;Dim&gt;, Frame::Inertial&gt;&gt;(
<span class="lineNum">     394 </span>            :               principal_dirichlet_auxiliary_field_fluxes));
<span class="lineNum">     395 </span>            :       for (auto it = numerical_flux_for_field-&gt;begin();
<span class="lineNum">     396 </span>            :            it != numerical_flux_for_field-&gt;end(); it++) {
<span class="lineNum">     397 </span>            :         *it *= 2 * penalty;
<span class="lineNum">     398 </span>            :       }
<span class="lineNum">     399 </span>            :     };
<span class="lineNum">     400 </span>            :     EXPAND_PACK_LEFT_TO_RIGHT(
<span class="lineNum">     401 </span>            :         assemble_dirichlet_penalty(FieldTags{}, numerical_flux_for_fields));
<span class="lineNum">     402 </span>            :   }
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :  private:
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   double penalty_parameter_ = std::numeric_limits&lt;double&gt;::signaling_NaN();</span>
<span class="lineNum">     406 </span>            : };
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            : }  // namespace NumericalFluxes
<span class="lineNum">     409 </span>            : }  // namespace dg
<span class="lineNum">     410 </span>            : }  // namespace elliptic
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
